## 2024 하반기 오전 1번 : 미지의 공간 탈출
> https://www.codetree.ai/ko/frequent-problems/problems/escape-unknown-space/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int dy[8] = { -1, 0, 1, 0, -1, 1, 1, -1 }, dx[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };
struct Pos {
    int y, x, faint;
    bool out;
    bool operator<(const Pos& rhs) const {
        if (y != rhs.y) return y > rhs.y;
        return x > rhs.x;
    }
};
int N, M, P, C, D, r_y, r_x, santa_cnt;
int board[50][50];
vector<Pos> santa;
vector<int> score;
void input();

int get_dist(int y0, int x0, int y1, int x1);

void move_rudolf();
void move_santa(int s);
void push_santa(int y, int x, int d);

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    input();

    for (int turn = 0; turn < M; ++turn) {
        // 1. 루돌프의 움직임
        move_rudolf();
        if (santa_cnt == 0) break;

        // 2. 산타의 움직임
        for (int s = 1; s <= P; ++s) {
            if (santa[s].out || santa[s].faint > 0) continue;
            move_santa(s);
        }
        if (santa_cnt == 0) break;

        // 3. 기절 시간 줄이기 && 탈락 안한 산타 1점 추가
        for (int s = 1; s <= P; ++s) {
            if (santa[s].out) continue;
            if (santa[s].faint > 0) {
                --santa[s].faint;
            }
            ++score[s];
        }
    }

    for (int s = 1; s <= P; ++s) {
        cout << score[s] << ' ';
    }

    return 0;
}

void move_santa(int s) {
    int dist, c_y = -1, c_x, c_d;
    int y = santa[s].y, x = santa[s].x;
    int min_dist = get_dist(y, x, r_y, r_x);

    // 이동할 좌표 찾기
    for (int d = 0; d < 4; ++d) {
        int yy = y + dy[d], xx = x + dx[d];
        if (yy < 0 || yy >= N || xx < 0 || xx >= N || board[yy][xx] != 0) continue;
        dist = get_dist(yy, xx, r_y, r_x);
        if (dist < min_dist) {
            min_dist = dist;
            c_y = yy; c_x = xx; c_d = d;
        }
    }

    if (c_y == -1) return;

    // 산타 이동
    board[y][x] = 0;
    board[c_y][c_x] = s;
    santa[s].y = c_y; santa[s].x = c_x;

    // 충돌 처리
    c_d = (c_d + 2) % 4;
    if (c_y == r_y && c_x == r_x) {
        score[s] += D;
        int yy = c_y + dy[c_d] * D, xx = c_x + dx[c_d] * D;
        if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
            board[c_y][c_x] = 0;
            santa[s].out = true;
            --santa_cnt;
        }
        else {
            if (board[yy][xx] != 0) {
                push_santa(yy, xx, c_d);
            }
            board[c_y][c_x] = 0;
            board[yy][xx] = s;
            santa[s].y = yy; santa[s].x = xx;
            santa[s].faint = 2;
        }
    }
}

void push_santa(int y, int x, int d) {
    int s = board[y][x];
    int yy = y + dy[d], xx = x + dx[d];
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
        santa[s].out = true;
        board[y][x] = 0;
        --santa_cnt;
        return;
    }
    if (board[yy][xx] != 0) {
        push_santa(yy, xx, d);
    }
    santa[s].y = yy; santa[s].x = xx;
    board[yy][xx] = board[y][x];
    board[y][x] = 0;
}

void move_rudolf() {
    vector<Pos> s_santa = santa;
    int dist, min_dist = 987654321, s_y, s_x;
    sort(s_santa.begin() + 1, s_santa.end());

    // 가장 가까운 산타의 좌표 찾기
    for (int s = 1; s <= P; ++s) {
        if (s_santa[s].out) continue;
        dist = get_dist(r_y, r_x, s_santa[s].y, s_santa[s].x);
        if (dist < min_dist) {
            min_dist = dist;
            s_y = s_santa[s].y; s_x = s_santa[s].x;
        }
    }

    min_dist = 987654321;
    int c_y, c_x, c_d;
    // (y, x)에 위치한 산타와 가장 가까운 방향으로 돌진
    for (int d = 0; d < 8; ++d) {
        int yy = r_y + dy[d], xx = r_x + dx[d];
        if (yy < 0 || yy >= N || xx < 0 || xx >= N) continue;
        dist = get_dist(s_y, s_x, yy, xx);
        if (dist < min_dist) {
            min_dist = dist;
            c_y = yy; c_x = xx; c_d = d;
        }
    }
    r_y = c_y; r_x = c_x;

    // 충돌 있다면 충돌
    if (board[r_y][r_x] != 0) {
        int s = board[r_y][r_x];
        score[s] += C;
        int yy = r_y + dy[c_d] * C, xx = r_x + dx[c_d] * C;
        if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
            board[r_y][r_x] = 0;
            santa[s].out = true;
            --santa_cnt;
        }
        else {
            if (board[yy][xx] != 0) {
                push_santa(yy, xx, c_d);
            }
            board[r_y][r_x] = 0;
            board[yy][xx] = s;
            santa[s].y = yy; santa[s].x = xx;
            santa[s].faint = 2;
        }
    }
}

int get_dist(int y0, int x0, int y1, int x1) {
    return (y0 - y1) * (y0 - y1) + (x0 - x1) * (x0 - x1);
}

void input() {
    cin >> N >> M >> P >> C >> D;
    cin >> r_y >> r_x;
    santa_cnt = P;
    --r_y; --r_x;
    santa.resize(P + 1);
    score.resize(P + 1, 0);
    for (int i = 0; i < P; ++i) {
        int p, y, x;
        cin >> p >> y >> x;
        santa[p] = { y - 1, x - 1, 0, false };
        board[y - 1][x - 1] = p;
    }
}

```
</details>

### 설명
 if (there.y < 0 || there.y >= 3 * M || there.x < 0 || there.x >= 3 * M) continue;
 이 부분에서 y y x x 순서로 제대로 했는지 꼭 확인하자.

 Pos get_there(Pos here, int d);
 0 1 2 3 이 0 1 2 3 과 만나는 것이 아니다.
 0 1 2 3 이 3 2 1 0 이렇게 만나는 경우도 반드시 생각하자.

***

## 2024 하반기 오전 2번 : 코드트리 DB
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-db/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
using namespace std;

struct Node {
  int left = 0, right = 0, count = 0;
  long long sum = 0;
};
vector<Node> tree;
void update(int node, int nl, int nr, int val, int count, int sum);
int query_rank(int node, int nl, int nr, int k);
long long query_sum(int node, int nl, int nr, int l, int r);

map<string, int> name_value;
map<int, string> value_name;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  string query_type, name;
  int Q, value, k;

  cin >> Q;
  while (Q--) {
    cin >> query_type;
    if (query_type == "init") {
      name_value.clear();
      value_name.clear();
      tree.clear();

      tree.push_back(Node());
      tree.push_back(Node());
    }
    else if (query_type == "insert") {
      cin >> name >> value;
      if (name_value.count(name) || value_name.count(value)) {
        cout << "0\n";
      }
      else {
        name_value[name] = value;
        value_name[value] = name;
        update(1, 1, 1e9, value, 1, value);
        cout << "1\n";
      }
    }
    else if (query_type == "delete") {
      cin >> name;
      if (name_value.count(name) == 0) {
        cout << "0\n";
      }
      else {
        int value = name_value[name];
        name_value.erase(name);
        value_name.erase(value);
        update(1, 1, 1e9, value, 0, 0);
        cout << value << '\n';
      }
    }
    else if (query_type == "rank") {
      cin >> k;
      if (tree[1].count < k) {
        cout << "None\n";
      }
      else {
        cout << value_name[query_rank(1, 1, 1e9, k)] << '\n';
      }
    }
    else if (query_type == "sum") {
      cin >> k;
      long long sum = query_sum(1, 1, 1e9, 1, k);
      cout << sum << '\n';
    }
  }
}

void update(int node, int nl, int nr, int val, int count, int sum) {
  if (val < nl || nr < val) return;
  if (nl == nr) {
    tree[node].count = count;
    tree[node].sum = sum;
    return;
  }
  int nm = (nl + nr) / 2;
  if (val <= nm) {
    if (tree[node].left == 0) {
      tree[node].left = tree.size();
      tree.push_back(Node());
    }
    update(tree[node].left, nl, nm, val, count, sum);
  }
  else {
    if (tree[node].right == 0) {
      tree[node].right = tree.size();
      tree.push_back(Node());
    }
    update(tree[node].right, nm + 1, nr, val, count, sum);
  }
  tree[node].count = tree[tree[node].left].count + tree[tree[node].right].count;
  tree[node].sum = tree[tree[node].left].sum + tree[tree[node].right].sum;
  return;
}

int query_rank(int node, int nl, int nr, int k) {
  if (nl == nr) return nl;
  int nm = (nl + nr) / 2;

  if (tree[tree[node].left].count >= k) {
    return query_rank(tree[node].left, nl, nm, k);
  }
  else {
    return query_rank(tree[node].right, nm + 1, nr, k - tree[tree[node].left].count);
  }
}

long long query_sum(int node, int nl, int nr, int l, int r) {
  if (r < nl || nr < l) return 0;
  if (l <= nl && nr <= r) return tree[node].sum;
  int nm = (nl + nr) / 2;
  long long ret = 0;
  if (tree[node].left) {
    ret += query_sum(tree[node].left, nl, nm, l, r);
  }
  if (tree[node].right) {
    ret += query_sum(tree[node].right, nm + 1, nr, l, r);
  }
  return ret;
}
```
</details>

### 설명
다이나믹 세그먼트 트리

일반적인 세그먼트 트리처럼 정해진 범위에 대해 모든 노드를 다 만드는 것이 아닌, 필요한 노드가 생길 때마다 노드를 동적으로 추가한다.

각 노드에 범위의 크기, 범위의 합, 왼쪽 노드 인덱스, 오른쪽 노드 인덱스를 갖도록 하고, update 연산이 주어질 때마다 노드를 추가한다.

이 문제에서는 1 ~ 10억 의 범위의 다이나믹 세그먼트 트리를 다루며, log(10억) = 32 이하이므로 한 번 update 마다 32 이하의 노드가 생기며, 한번의 쿼리도 O(32) 의 시간복잡도를 갖는다.

***

## 2024 하반기 오후 1번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2024 하반기 오후 2번 : 코드트리 등산 게임
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-mountain-climbing-games/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int Q, n, h, order_type;
vector<int> idx;
vector<vector<int>> mount;

bool cmp(const vector<int>& vec, int v) {
  return vec.back() < v;
}

void insert(int h) {
  /*
  int l = 0, r = mount.size();
  while (l < r) {
    int m = (l + r) / 2;
    if (mount[m].back() < h) {
      l = m + 1;
    }
    else {
      r = m;
    }
  }
  if (r == mount.size()) {
    mount.push_back(vector<int>(1, h));
  }
  else {
    mount[l].push_back(h);
  }
  idx.push_back(l);
  */

  auto it = lower_bound(mount.begin(), mount.end(), h, cmp);
  if (it == mount.end()) {
    idx.push_back(mount.size());
    mount.push_back(vector<int>(1, h));
  }
  else {
    idx.push_back(it - mount.begin());
    it->push_back(h);
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cin >> Q;
  while (Q--) {
    cin >> order_type;
    if (order_type == 100) {
      cin >> n;
      for (int i = 0; i < n; ++i) {
        cin >> h;
        insert(h);
      }
    }
    else if (order_type == 200) {
      cin >> h;
      insert(h);

    }
    else if (order_type == 300) {
      mount[idx.back()].pop_back();
      if (mount.back().empty()) {
        mount.pop_back();
      }
      idx.pop_back();
    }
    else if (order_type == 400) {
      int m_idx; cin >> m_idx; --m_idx;
      long long score = 1000000;
      score *= (idx[m_idx] + mount.size());
      score += mount.back().front();;
      printf("%lld\n", score);
    }
  }
  return 0;
}
```
</details>

### 설명
LIS(Longest Increasing Subsequence) 를 활용하는 문제.

알려진 해법과 다른 점은, 지우는 경우도 있으므로 vector<int> 가 아닌

vector<vector<int>> 로 지우는 것이 아니라 back 에 추가하는 방식을 사용한다.

다음은 lower_bound 에 사용자 정의 기준 함수 넣는 방법이다.

lower_bound(first, end, value, comp);

bool comp(element, value);

형태이다.

***

## 2024 상반기 오전 1번: 고대 문명 유적 탐사
> https://www.codetree.ai/ko/frequent-problems/problems/ancient-ruin-exploration/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int dy[4] = { -1, 1, 0, 0 }, dx[4] = { 0, 0, -1, 1 };
struct Pos { int y, x; };
struct Info {
  int board[5][5];
  void rotate(int y, int x, int t);
};

int K, M, wall_num[300], wall_idx;
bool discovered[5][5];
Info info;
void input();

Pos cand; int cand_d;
bool get_max_gold();
int get_value_1(int y, int x, int d);
int clear_gold(int (*board)[5]);

void fill_gold();

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();
  for (int turn = 0; turn < K; ++turn) {
    // 1. 유적 획득 가치 최대 좌표, 회전 횟수 구하기
    if (!get_max_gold()) {
      break;
    }
    // 2. 최대 유물 1차 획득할 수 있도록 회전
    info.rotate(cand.y, cand.x, cand_d);
    // 3. 유물 연쇄 획득 과정 수행
    int v_sum = 0;
    while (true) {
      // 1. 유물 사라지기
      int v = clear_gold(info.board);
      if (v == 0) break;
      v_sum += v;
      // 2. 유물 채우기
      fill_gold();
    }
    cout << v_sum << ' ';
  }
  return 0;
}

void fill_gold() {
  for (int x = 0; x < 5; ++x) {
    for (int y = 4; y >= 0; --y) {
      if (info.board[y][x] == 0) {
        info.board[y][x] = wall_num[wall_idx++];
      }
    }
  }
}

bool get_max_gold() {
  int max_val = 0; // 최대 획득 가치
  int value[3][3][4]; // y, x, 회전횟수

  for (int d = 1; d <= 3; ++d) {
    for (int x = 0; x < 3; ++x) {
      for (int y = 0; y < 3; ++y) {
        value[y][x][d] = get_value_1(y, x, d);
        max_val = max(max_val, value[y][x][d]);
      }
    }
  }

  if (max_val == 0) return false;

  for (int d = 1; d <= 3; ++d) {
    for (int x = 0; x < 3; ++x) {
      for (int y = 0; y < 3; ++y) {
        if (value[y][x][d] == max_val) {
          cand = { y, x };
          cand_d = d;
          return true;
        }
      }
    }
  }

  return true;
}

int get_value_1(int y, int x, int d) {
  Info tmp = info;
  tmp.rotate(y, x, d);
  return clear_gold(tmp.board);
}

int clear_gold(int (*board)[5]) {
  memset(discovered, false, sizeof(discovered));
  int ret = 0;

  for (int y = 0; y < 5; ++y) {
    for (int x = 0; x < 5; ++x) {
      if (!discovered[y][x]) {
        queue<Pos> q;
        vector<Pos> v;
        discovered[y][x] = true;
        q.push({ y, x });
        while (!q.empty()) {
          Pos here = q.front(); q.pop();
          v.push_back(here);
          for (int d = 0; d < 4; ++d) {
            int yy = here.y + dy[d], xx = here.x + dx[d];
            if (yy < 0 || yy >= 5 || xx < 0 || xx >= 5) continue;
            if (!discovered[yy][xx] && board[here.y][here.x] == board[yy][xx]) {
              discovered[yy][xx] = true;
              q.push({ yy, xx });
            }
          }
        }
        if (v.size() >= 3) {
          ret += v.size();
          for (Pos& p : v) {
            board[p.y][p.x] = 0;
          }
        }
      }
    }
  }

  return ret;
}

void Info::rotate(int y, int x, int t) {
  int tmp[5][5];
  while (t--) {
    memcpy(tmp, board, sizeof(board));
    for (int i = 0; i < 3; ++i) {
      for (int j = 0; j < 3; ++j) {
        tmp[y + j][x + 2 - i] = board[y + i][x + j];
      }
    }
    memcpy(board, tmp, sizeof(board));
  }
}

void input() {
  cin >> K >> M;
  for (int y = 0; y < 5; ++y) {
    for (int x = 0; x < 5; ++x) {
      cin >> info.board[y][x];
    }
  }
  for (int i = 0; i < M; ++i) {
    cin >> wall_num[i];
  }
}
```
</details>

### 설명
BFS 구현 문제

***

## 2024 상반기 오전 2번
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-tour/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

#define INF 987654321

struct Info {
  int revenue, dest;
  bool deleted;
  Info(int revenue, int dest, bool deleted) : revenue(revenue), dest(dest), deleted(deleted) {}
  Info() : deleted(false) {}
};

struct Info2 {
  int profit, id;
  bool operator<(const Info2& rhs) const {
    if (profit != rhs.profit) {
      return profit < rhs.profit;
    }
    return id > rhs.id;
  }
};

int Q, n, m, source;
vector<vector<pair<int, int>>> adj;
vector<int> dist;
void input();
void dijkstra();

Info products[30001];
priority_queue<Info2> ordered;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();
  while (Q--) {
    int order_type; cin >> order_type;
    // 여행 상품 생성
    if (order_type == 200) {
      int id, revenue, dest;
      cin >> id >> revenue >> dest;
      products[id] = { revenue, dest, false };
      ordered.push({ revenue - dist[dest], id });
    }
    // 여행 상품 취소
    else if (order_type == 300) {
      int id; cin >> id;
      if (!products[id].deleted) {
        products[id].deleted = true;
      }
    }
    // 최적의 여행 상품 판매
    else if (order_type == 400) {
      bool sell = false;
      while (!ordered.empty()) {
        Info2 info = ordered.top();
        if (products[info.id].deleted) {
          ordered.pop();
        }
        else if (info.profit < 0) {
          break;
        }
        else {
          cout << info.id << '\n';
          products[info.id].deleted = true;
          ordered.pop();
          sell = true;
          break;
        }
      }
      if (!sell) {
        cout << "-1\n";
      }
    }
    // 여행 상품의 출발지 변경
    else if (order_type == 500) {
      int s; cin >> s;
      source = s;
      dijkstra();
      priority_queue<Info2> tmp;
      while (!ordered.empty()) {
        Info2 i2 = ordered.top(); ordered.pop();
        if (products[i2.id].deleted) continue;
        Info& p = products[i2.id];
        tmp.push({ p.revenue - dist[p.dest], i2.id });
      }
      ordered = tmp;
    }
  }
  return 0;
}

void dijkstra() {
  dist = vector<int>(n, INF);
  priority_queue<pair<int, int>> pq;

  dist[source] = 0;
  pq.push({ -0, source });

  while (!pq.empty()) {
    int here = pq.top().second, cost = -pq.top().first; pq.pop();
    if (dist[here] < cost) continue;
    for (int i = 0; i < adj[here].size(); ++i) {
      int there = adj[here][i].first, next_cost = cost + adj[here][i].second;
      if (dist[there] > next_cost) {
        dist[there] = next_cost;
        pq.push({ -next_cost, there });
      }
    }
  }
}

void input() {
  cin >> Q;
  cin >> n; // 100 
  cin >> n >> m;
  adj.resize(n);
  int u, v, w;
  for (int i = 0; i < m; ++i) {
    cin >> u >> v >> w;
    adj[u].emplace_back(v, w);
    adj[v].emplace_back(u, w);
  }
  dijkstra();
  --Q;
}
```
</details>

다익스트라 + 우선순위 큐를 사용하는 문제.

다익스트라 알고리즘은 O(ElogE) 이지만, 출발지 변경이 최대 15번이므로 가능하다.

다익스트라 알고리즘은 '방향그래프' 기준이므로 무향그래프가 주어진다면, 무향 그래프의 무향 간선을 두개의 방향 간선으로 나누어 주어야 한다.

또한 다익스트라 알고리즘은 같은 정점들을 연결하는 간선들이 여러개 주어져도 상관 없다.

***

## 2024 상반기 오후 1번 : 마법의 숲 탐색
> https://www.codetree.ai/ko/frequent-problems/problems/magical-forest-exploration/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

const int dy[4] = { -1, 0, 1, 0 }, dx[4] = { 0, 1, 0, -1 };
struct Pos { int y, x, d; };
int R, C, K, board[73][70]; // 3칸 추가됨, 0: 빈칸, 1 ~ K: 골렘, K + 1 ~ K + K: 출구

const int down_y[3] = { 1, 2, 1 }, down_x[3] = { -1, 0, 1 };
const int left_y[5] = { -1, 0, 1, 1, 2 }, left_x[5] = { -1, -2, -1, -2, -1 };
const int right_y[5] = { -1, 0, 1, 1, 2 }, right_x[5] = { 1, 2, 1, 2, 1 };
Pos gol;

bool go_down();
bool go_left();
bool go_right();

int score;
bool discovered[73][70];
void move();

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cin >> R >> C >> K;
  R += 3; // 위쪽으로 세 칸 추가
  for (int num = 1; num <= K; ++num) {
    cin >> gol.x >> gol.d;
    --gol.x; gol.y = 1;
    // 골렘 이동
    while (true) {
      // 아래 이동 확인
      if (go_down()) {
        continue;
      }
      // 왼쪽 이동 확인
      else if (go_left()) {
        continue;
      }
      // 오른쪽 이동 확인
      else if (go_right()) {
        continue;
      }
      // 더 이상 이동 불가
      else {
        break;
      }
    }
    // 숲을 벗어난 상태
    if (gol.y < 4) {
      memset(board, 0, sizeof(board));
      continue;
    }
    // board에 추가
    for (int d = 0; d < 4; ++d) {
      if (d == gol.d) {
        board[gol.y + dy[d]][gol.x + dx[d]] = K + num;
      }
      else {
        board[gol.y + dy[d]][gol.x + dx[d]] = num;
      }
    }
    board[gol.y][gol.x] = num;
    // 7. 정령의 이동
    move();
  }
  cout << score;
  return 0;
}

void move() {
  memset(discovered, false, sizeof(discovered));
  queue<Pos> q;
  int ret = 0;

  discovered[gol.y][gol.x] = true;
  q.push({ gol.y, gol.x });

  while (!q.empty()) {
    Pos here = q.front(); q.pop();
    ret = max(ret, here.y - 2);
    for (int d = 0; d < 4; ++d) {
      int yy = here.y + dy[d], xx = here.x + dx[d];
      if (yy < 0 || yy >= R || xx < 0 || xx >= C || discovered[yy][xx] || board[yy][xx] == 0) continue;
      if (board[here.y][here.x] == board[yy][xx] || board[here.y][here.x] + K == board[yy][xx] || board[here.y][here.x] > K) {
        discovered[yy][xx] = true;
        q.push({ yy, xx });
      }
    }
  }
  score += ret;
}

bool go_right() {
  for (int i = 0; i < 5; ++i) {
    int yy = gol.y + right_y[i], xx = gol.x + right_x[i];
    if (yy < 0 || yy >= R || xx < 0 || xx >= C) return false;
    if (board[yy][xx] >= 1) return false;
  }
  gol.y += 1; gol.x += 1;
  gol.d = (gol.d + 1) % 4;
  return true;
}

bool go_left() {
  for (int i = 0; i < 5; ++i) {
    int yy = gol.y + left_y[i], xx = gol.x + left_x[i];
    if (yy < 0 || yy >= R || xx < 0 || xx >= C) return false;
    if (board[yy][xx] >= 1) return false;
  }
  gol.y += 1; gol.x -= 1;
  gol.d = (gol.d + 3) % 4;
  return true;
}

bool go_down() {
  for (int i = 0; i < 3; ++i) {
    int yy = gol.y + down_y[i], xx = gol.x + down_x[i];
    if (yy < 0 || yy >= R || xx < 0 || xx >= C) return false;
    if (board[yy][xx] >= 1) return false;
  }
  gol.y += 1;
  return true;
}
```
</details>

### 설명
복잡한 구현 문제

검사해야 하는 범위가 있다면, 해당 검사 범위에 해당하는 dy, dx를 미리 배열에 저장해 놓으면 쉽게 검사할 수 있다.

***

## 2024 상반기 오후 2번 : 색깔 트리
> https://www.codetree.ai/ko/frequent-problems/problems/color-tree/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Node {
  int color, depth, parent, created_t, color_t;
  vector<int> children;
};

int Q;
vector<int> root;
Node tree[100001];

bool check_d(int p, int d_limit);

int score;
int calc_value(int p, int c_color_t, int c_color);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  cin >> Q;
  for (int turn = 0; turn < Q; ++turn) {
    int q_type; cin >> q_type;
    // 노드 추가
    if (q_type == 100) {
      int m_id, p_id, color, depth;
      cin >> m_id >> p_id >> color >> depth;

      // 주어진 부모가 추가 안된 노드
      if (p_id != -1 && tree[p_id].parent == 0) continue;
      // 깊이 모순 확인
      if (p_id != -1 && !check_d(p_id, 2)) continue;
      // 노드 추가
      tree[m_id] = { color, depth, p_id, turn, -1 };
      if (p_id != -1) {
        tree[p_id].children.push_back(m_id);
      }
      else {
        root.push_back(m_id);
      }
    }
    // 색깔 변경. c_color에 색 기록.
    else if (q_type == 200) {
      int m_id, color;
      cin >> m_id >> color;
      tree[m_id].color = color;
      tree[m_id].color_t = turn;
    }
    // 부모를 타고 올라가며 color_t 값이 가장 큰 color 값으로 갱신
    else if (q_type == 300) {
      int m_id; cin >> m_id;

      // 추가 안된 노드일 경우 넘어감
      if (tree[m_id].parent == 0) continue;

      int color = tree[m_id].color;
      int p = m_id;
      int max_c_color_t = max(tree[m_id].created_t, tree[m_id].color_t);
      while (true) {
        if (tree[p].parent == -1) break;
        p = tree[p].parent;
        if (tree[p].color_t > max_c_color_t) {
          max_c_color_t = tree[p].color_t;
          color = tree[p].color;
        }
      }
      tree[m_id].color = color;
      cout << color << '\n';
    }
    else if (q_type == 400) {
      score = 0;
      for (int r : root) {
        calc_value(r, tree[r].color_t, tree[r].color);
      }
      cout << score << '\n';
    }
  }
}

int calc_value(int p, int color_t, int color) {
  int next_color_t = color_t, next_color = color;
  if (color_t < tree[p].color_t) {
    next_color_t = tree[p].color_t;
    next_color = tree[p].color;
  }

  if (color_t > max(tree[p].color_t, tree[p].created_t)) {
    tree[p].color = color;
  }

  int mask = (1 << tree[p].color);
  for (int c : tree[p].children) {
    mask |= calc_value(c, next_color_t, next_color);
  }

  int cnt = 0;
  for (int i = 1; i <= 5; ++i) {
    if (mask & (1 << i)) ++cnt;
  }
  score += cnt * cnt;

  return mask;
}

bool check_d(int p, int d_limit) {
  if (tree[p].depth < d_limit) return false;
  if (tree[p].parent != -1) {
    return check_d(tree[p].parent, d_limit + 1);
  }
  else {
    return true;
  }
}
```
</details>

### 설명
트리 문제.

어떤 노드를 루트로 하는 트리의 색을 변경할 때마다 탐색을 하며 색을 바꿔주면, 시간을 초과하게 된다.

이 문제에서의 힌트는 최대 깊이가 100 이하이므로, 트리의 루트까지 탐색하여 올라가는 과정이 O(100) 이라는 것이다.

즉 어떤 노드의 색을 조회할 때, 부모까지 타고 올라가며 해당 노드의 탄생 시간 이후, 또는 해당 노드의 색 변화 이후 변화된 색이 있다면 그 색으로 바꾸어주면 된다.

또한 모든 노드의 가치를 계산할 때에도 루트부터 가장 이후에 변화된 색과 시간을 전파하며 아래로 내려가며 계산한다.

***

## 2023 하반기 오전 1번 : 왕실의 기사 대결
> https://www.codetree.ai/ko/frequent-problems/problems/royal-knight-duel/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

const int dy[4] = { -1, 0, 1, 0 }, dx[4] = { 0, 1, 0, -1 };
struct Horse {
	int y, x, h, w, hp;
};
int L, N, Q, board[42][42], WALL;
bool attack[42][42];
vector<Horse> horses;
vector<int> attack_sum;

void input();

bool can_move(int i, int d);
bool check_horses(int y, int x, int h, int w, set<int>& sets);
void move_horses(int i, int d);
void damage(int num);

void print() {
	cout << endl;
	for (int i = 0; i <= L + 1; ++i) {
		for (int j = 0; j <= L + 1; ++j) {
			cout << board[i][j] << ' ';
		}
		cout << endl;
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	input();
	while (Q--) {
		int i, d;
		cin >> i >> d;
		if (horses[i].hp <= 0) continue;
		if (!can_move(i, d)) continue;
		move_horses(i, d);
		
	}
	int sum = 0;
	for (int i = 1; i <= N; ++i) {
		if (horses[i].hp > 0) {
			sum += attack_sum[i];
		}
	}
	cout << sum;

	return 0;
}

void damage(int num) {
	for (int i = 0; i < horses[num].h; ++i) {
		for (int j = 0; j < horses[num].w; ++j) {
			if (attack[horses[num].y + i][horses[num].x + j]) {
				--horses[num].hp;
				++attack_sum[num];
			}
		}
	}
	if (horses[num].hp <= 0) {
		for (int i = 0; i < horses[num].h; ++i) {
			for (int j = 0; j < horses[num].w; ++j) {
				board[horses[num].y + i][horses[num].x + j] = 0;
			}
		}
	}
}

void move_horses(int i, int d) {
	int yy = horses[i].y + dy[d], xx = horses[i].x + dx[d];
	set<int> sets;

	check_horses(yy, xx, horses[i].h, horses[i].w, sets);
	if (sets.count(i)) {
		sets.erase(i);
	}

	for (int i : sets) {
		move_horses(i, d);
		damage(i);
	}
	if (d == 0) { // 위쪽
		for (int x = 0; x < horses[i].w; ++x) {
			board[horses[i].y - 1][horses[i].x + x] = i;
			board[horses[i].y + horses[i].h - 1][horses[i].x + x] = 0;
		}
	}
	else if (d == 1) { // 오른쪽
		for (int y = 0; y < horses[i].h; ++y) {
			board[horses[i].y + y][horses[i].x + horses[i].w] = i;
			board[horses[i].y + y][horses[i].x] = 0;
		}
	}
	else if (d == 2) { // 아래쪽
		for (int x = 0; x < horses[i].w; ++x) {
			board[horses[i].y + horses[i].h][horses[i].x + x] = i;
			board[horses[i].y][horses[i].x + x] = 0;
		}
	}
	else if (d == 3) { // 왼쪽
		for (int y = 0; y < horses[i].h; ++y) {
			board[horses[i].y + y][horses[i].x - 1] = i;
			board[horses[i].y + y][horses[i].x + horses[i].w - 1] = 0;
		}
	}
	horses[i].y = yy; horses[i].x = xx;
}

// i번 말이 움직일 수 있는지 조사
bool can_move(int i, int d) {
	int yy = horses[i].y + dy[d], xx = horses[i].x + dx[d];

	// 1. 움직였을때 벽과 겹치는지, 겹치지 않는다면 겹치는 다른 말 구하기
	set<int> sets;
	if (!check_horses(yy, xx, horses[i].h, horses[i].w, sets)) {
		return false;
	}
	if (sets.count(i)) {
		sets.erase(i);
	}
	
	// 2. 움직였을 때 겹치는 다른 말이 움직일 수 있는지 조사
	for (int h : sets) {
		if (!can_move(h, d)) {
			return false;
		}
	}

	return true;
}

// 이동했을 때 겹치는 말 반환 && 벽과 겹치는지 조사
bool check_horses(int y, int x, int h, int w, set<int>& sets) {
	for (int i = 0; i < h; ++i) {
		for (int j = 0; j < w; ++j) {
			if (board[y + i][x + j] == WALL) {
				return false;
			}
			if (board[y + i][x + j] >= 1) {
				sets.insert(board[y + i][x + j]);
			}
		}
	}
	return true;
}

void input() {
	cin >> L >> N >> Q;
	WALL = N + 1;

	for (int y = 1; y <= L; ++y) {
		for (int x = 1; x <= L; ++x) {
			cin >> board[y][x];
			if (board[y][x] == 2) {
				board[y][x] = WALL;
			}
			else if (board[y][x] == 1) {
				board[y][x] = 0;
				attack[y][x] = true;
			}
		}
	}

	for (int i = 0; i <= L + 1; ++i) {
		board[0][i] = board[L + 1][i] = WALL;
		board[i][0] = board[i][L + 1] = WALL;
	}

	horses.resize(N + 1);
	attack_sum.resize(N + 1, 0);
	for (int i = 1; i <= N; ++i) {
		cin >> horses[i].y >> horses[i].x >> horses[i].h >> horses[i].w >> horses[i].hp;
		for (int a = 0; a < horses[i].h; ++a) {
			for (int b = 0; b < horses[i].w; ++b) {
				board[horses[i].y + a][horses[i].x + b] = i;
			}
		}
	}
}
```
</details>

### 설명
재귀함수를 이용하여 가장 나중에 밀려나는 기사부터 처리해나가는 문제.

이동시 겹치는 기사를 구할 때 자기 자신을 빼도록 해야 한다.

***

## 2023 하반기 오전 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2023 하반기 오후 1번 : 루돌프의 반란
> https://www.codetree.ai/ko/frequent-problems/problems/rudolph-rebellion/description

### 코드
<details>
<summary>C++</summary>

```cpp
// 문제 종료 조건 확인하기!!!!!!!!!!!!!!!
// 모든 산타가 게임에서 탈락하면 그 즉시 게임은 종료된다.

// board[y][x] 를 board[yy][xx] 로 옮길 때,
// board[y][x] = 0 을 먼저 하고 옮기는 실수 하지 않기.

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int dy[8] = { -1, 0, 1, 0, -1, 1, 1, -1 }, dx[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };
struct Pos {
  int y, x, faint;
  bool out;
  bool operator<(const Pos& rhs) const {
    if (y != rhs.y) return y > rhs.y;
    return x > rhs.x;
  }
};
int N, M, P, C, D, r_y, r_x, santa_cnt;
int board[50][50];
vector<Pos> santa;
vector<int> score;
void input();

int get_dist(int y0, int x0, int y1, int x1);

void move_rudolf();
void move_santa(int s);
void push_santa(int y, int x, int d);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();

  for (int turn = 0; turn < M; ++turn) {
    // 1. 루돌프의 움직임
    move_rudolf();
    if (santa_cnt == 0) break;

    // 2. 산타의 움직임
    for (int s = 1; s <= P; ++s) {
      if (santa[s].out || santa[s].faint > 0) continue;
      move_santa(s);
    }
    if (santa_cnt == 0) break;

    // 3. 기절 시간 줄이기 && 탈락 안한 산타 1점 추가
    for (int s = 1; s <= P; ++s) {
      if (santa[s].out) continue;
      if (santa[s].faint > 0) {
        --santa[s].faint;
      }
      ++score[s];
    }
  }

  for (int s = 1; s <= P; ++s) {
    cout << score[s] << ' ';
  }

  return 0;
}

void move_santa(int s) {
  int dist, c_y = -1, c_x, c_d;
  int y = santa[s].y, x = santa[s].x;
  int min_dist = get_dist(y, x, r_y, r_x);

  // 이동할 좌표 찾기
  for (int d = 0; d < 4; ++d) {
    int yy = y + dy[d], xx = x + dx[d];
    if (yy < 0 || yy >= N || xx < 0 || xx >= N || board[yy][xx] != 0) continue;
    dist = get_dist(yy, xx, r_y, r_x);
    if (dist < min_dist) {
      min_dist = dist;
      c_y = yy; c_x = xx; c_d = d;
    }
  }

  if (c_y == -1) return;

  // 산타 이동
  board[y][x] = 0;
  board[c_y][c_x] = s;
  santa[s].y = c_y; santa[s].x = c_x;

  // 충돌 처리
  c_d = (c_d + 2) % 4;
  if (c_y == r_y && c_x == r_x) {
    score[s] += D;
    int yy = c_y + dy[c_d] * D, xx = c_x + dx[c_d] * D;
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
      board[c_y][c_x] = 0;
      santa[s].out = true;
      --santa_cnt;
    }
    else {
      if (board[yy][xx] != 0) {
        push_santa(yy, xx, c_d);
      }
      board[c_y][c_x] = 0;
      board[yy][xx] = s;
      santa[s].y = yy; santa[s].x = xx;
      santa[s].faint = 2;
    }
  }
}

void push_santa(int y, int x, int d) {
  int s = board[y][x];
  int yy = y + dy[d], xx = x + dx[d];
  if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
    santa[s].out = true;
    board[y][x] = 0;
    --santa_cnt;
    return;
  }
  if (board[yy][xx] != 0) {
    push_santa(yy, xx, d);
  }
  santa[s].y = yy; santa[s].x = xx;
  board[yy][xx] = board[y][x];
  board[y][x] = 0;
}

void move_rudolf() {
  vector<Pos> s_santa = santa;
  int dist, min_dist = 987654321, s_y, s_x;
  sort(s_santa.begin() + 1, s_santa.end());

  // 가장 가까운 산타의 좌표 찾기
  for (int s = 1; s <= P; ++s) {
    if (s_santa[s].out) continue;
    dist = get_dist(r_y, r_x, s_santa[s].y, s_santa[s].x);
    if (dist < min_dist) {
      min_dist = dist;
      s_y = s_santa[s].y; s_x = s_santa[s].x;
    }
  }

  min_dist = 987654321;
  int c_y, c_x, c_d;
  // (y, x)에 위치한 산타와 가장 가까운 방향으로 돌진
  for (int d = 0; d < 8; ++d) {
    int yy = r_y + dy[d], xx = r_x + dx[d];
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) continue;
    dist = get_dist(s_y, s_x, yy, xx);
    if (dist < min_dist) {
      min_dist = dist;
      c_y = yy; c_x = xx; c_d = d;
    }
  }
  r_y = c_y; r_x = c_x;

  // 충돌 있다면 충돌
  if (board[r_y][r_x] != 0) {
    int s = board[r_y][r_x];
    score[s] += C;
    int yy = r_y + dy[c_d] * C, xx = r_x + dx[c_d] * C;
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
      board[r_y][r_x] = 0;
      santa[s].out = true;
      --santa_cnt;
    }
    else {
      if (board[yy][xx] != 0) {
        push_santa(yy, xx, c_d);
      }
      board[r_y][r_x] = 0;
      board[yy][xx] = s;
      santa[s].y = yy; santa[s].x = xx;
      santa[s].faint = 2;
    }
  }
}

int get_dist(int y0, int x0, int y1, int x1) {
  return (y0 - y1) * (y0 - y1) + (x0 - x1) * (x0 - x1);
}

void input() {
  cin >> N >> M >> P >> C >> D;
  cin >> r_y >> r_x;
  santa_cnt = P;
  --r_y; --r_x;
  santa.resize(P + 1);
  score.resize(P + 1, 0);
  for (int i = 0; i < P; ++i) {
    int p, y, x;
    cin >> p >> y >> x;
    santa[p] = { y - 1, x - 1, 0, false };
    board[y - 1][x - 1] = p;
  }
}
```
</details>

### 설명
**문제 종료 조건 확인하기**
   모든 산타가 게임에서 탈락하면 그 즉시 게임은 종료된다.

board[y][x] 를 board[yy][xx] 로 옮길 때,
board[y][x] = 0 을 먼저 하고 옮기는 실수 하지 않기.

***

## 2023 하반기 오후 2번 : 코드트리 오마카세
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-omakase/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

struct Sushi { int t, x; };
struct Q_Node {
  int t; string name;
  bool operator<(const Q_Node& rhs) const {
    return t > rhs.t;
  }
};
struct G_Node {
  int n, x;
};
unordered_map<string, vector<Sushi>> sushi;
unordered_map<string, G_Node> guests;
priority_queue<Q_Node> query;

int L, Q, guest_num, sushi_num;

void make_query(string& name, int t, int x);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  cin >> L >> Q;
  int q_type, t, x, n;
  string name;

  while (Q--) {
    cin >> q_type;
    if (q_type == 100) {
      ++sushi_num;
      cin >> t >> x >> name;
      if (guests.count(name) == 0) {
        sushi[name].push_back({ t, x });
      }
      else {
        G_Node& guest = guests[name];
        if (x == guest.x) {
          --sushi_num;
          if (--guest.n == 0) {
            --guest_num;
          }
        }
        else if (x < guest.x) {
          query.push({ t + guest.x - x, name });
        }
        else {
          query.push({ t + guest.x + L - x, name });
        }
      }
    }
    else if (q_type == 200) {
      ++guest_num;
      cin >> t >> x >> name >> n;
      guests[name] = { n, x };
      make_query(name, t, x);
    }
    else if (q_type == 300) {
      cin >> t;
      while (!query.empty()) {
        if (query.top().t <= t) {
          string name = query.top().name;
          --guests[name].n;
          if (guests[name].n == 0) {
            --guest_num;
          }
          --sushi_num;
          query.pop();
        }
        else {
          break;
        }
      }
      cout << guest_num << ' ' << sushi_num << '\n';
    }
  }
}

void make_query(string& name, int t, int x) {
  vector<Sushi>& v = sushi[name];
  for (Sushi& s : v) {
    s.x = (s.x + t - s.t) % L;
    if (s.x == x) {
      --guests[name].n;
      --sushi_num;
      if (guests[name].n == 0) {
        --guest_num;
      }
      continue;
    }
    else if (x > s.x) {
      query.push({ t + x - s.x, name });
    }
    else {
      query.push({ t + x + L - s.x, name });
    }
  }
  v.clear();
}
```
</details>

### 설명
사람이 착석한 이후부터는, 스시들이 먹히는 시간을 계산할 수 있게 된다.

따라서 사람이 착석할 때, 존재하는 스시들을 {먹히는 시간, 스시 이름} 의 형태로 우선순위 큐에 저장하고,

사진 촬영을 할 때, 즉 쿼리가 주어질 때, 우선순위 큐에서 해당 시간 이전에 먹히는 모든 스시들을 처리하고 출력을 진행한다.

이러면, 스시들의 개수만큼 쿼리에 들어가고 나가게 되므로 시간 안에 수행할 수 있다.

**시간 복잡도 개선을 위해 해시맵과 해시셋을 사용한다**

해시맵과 해시 셋은, 내부를 정렬하지는 않지만 검색을 O(1) 에 수행한다.

***

## 2023 상반기 오전 1번 : 포탑 부수기
> https://www.codetree.ai/ko/frequent-problems/problems/destroy-the-turret/description?introductionSetId=&bookmarkId=

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

#define INF 987654321

const int dy[8] = { 0, 1, 0, -1 , -1, -1, 1, 1 }, dx[8] = { 1, 0, -1, 0 , -1, 1, -1, 1 };
struct Pos { int y, x; };
int N, M, K, tower_cnt;
int power[10][10], att_t[10][10], rc_sum[10][10];
bool associate[10][10];
void input();
Pos from, to;

void choose_atk();
void choose_atked();
Pos next(Pos p, int d);
bool razer_atk();
void bomb_atk();
void fix_tower();
void print();

// 부서지지 않은 포탑 1개 -> 즉시 종료
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();

  for (int turn = 1; turn <= K; ++turn) {
    // 0. 초기화
    memset(associate, false, sizeof(associate));
    // 1. 공격자 선정 및 공격력 증가 && 공격자 체크
    choose_atk();
    power[from.y][from.x] += (N + M);
    att_t[from.y][from.x] = turn;
    associate[from.y][from.x] = true;
    // 2. 공격 대상 선정
    choose_atked();
    // 3. 레이저 공격 && 피해 입은 포탑 체크
    if (!razer_atk()) {
      // 4. 레이저 실패 시 폭탄 공격 && 피해 입은 포탑 체크
      bomb_atk();
    }
    // 5. 포탑 정비
    fix_tower();
    if (tower_cnt == 1) break;
  }

  int max_att = 0;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      max_att = max(max_att, power[y][x]);
    }
  }
  cout << max_att;

  return 0;
}

void fix_tower() {
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      if (power[y][x] <= 0) continue;
      if (!associate[y][x]) {
        ++power[y][x];
      }
    }
  }
}

void bomb_atk() {
  power[to.y][to.x] -= power[from.y][from.x];
  if (power[to.y][to.x] <= 0) --tower_cnt;
  associate[to.y][to.x] = true;

  for (int d = 0; d < 8; ++d) {
    Pos adj = next(to, d);
    if (power[adj.y][adj.x] > 0 && !(adj.y == from.y && adj.x == from.x)) {
      power[adj.y][adj.x] -= power[from.y][from.x] / 2;
      if (power[adj.y][adj.x] <= 0) --tower_cnt;
      associate[adj.y][adj.x] = true;
    }
  }
}

Pos next(Pos p, int d) {
  int yy = p.y + dy[d], xx = p.x + dx[d];
  if (yy == -1) yy = N - 1; if (yy == N) yy = 0;
  if (xx == -1) xx = M - 1; if (xx == M) xx = 0;
  return { yy, xx };
}

bool razer_atk() {
  vector<vector<int>> dist(N, vector<int>(M, INF));
  vector<vector<Pos>> parent(N, vector<Pos>(M, { -1, -1 }));
  queue<Pos> q;

  dist[from.y][from.x] = 0;
  q.push(from);

  while (!q.empty()) {
    Pos here = q.front(); q.pop();
    for (int d = 0; d < 4; ++d) {
      Pos there = next(here, d);
      if (power[there.y][there.x] <= 0 || dist[there.y][there.x] != INF) continue;
      dist[there.y][there.x] = dist[here.y][here.x] + 1;
      parent[there.y][there.x] = here;
      q.push(there);
    }
  }
  if (dist[to.y][to.x] == INF) return false;

  // 공격 대상 공격자의 공격력만큼 피해 입히기
  power[to.y][to.x] -= power[from.y][from.x];
  if (power[to.y][to.x] <= 0) --tower_cnt;
  associate[to.y][to.x] = true;

  // 경로 따라 가며 절반만큼 피해 입히기
  Pos t = parent[to.y][to.x];
  while (!(t.y == from.y && t.x == from.x)) {
    associate[t.y][t.x] = true;
    power[t.y][t.x] -= power[from.y][from.x] / 2;
    if (power[t.y][t.x] <= 0) --tower_cnt;
    t = parent[t.y][t.x];
  }

  return true;
}

void choose_atked() {
  // 가장 큰 공격력 찾기
  int max_p = 0;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      if (power[y][x] <= 0 || (y == from.y && x == from.x)) continue;
      max_p = max(max_p, power[y][x]);
    }
  }
  // 가장 큰 공격력 중에서 가장 오래전에 공격한 포탑 찾기
  int longest_att = INF;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      if (power[y][x] <= 0 || (y == from.y && x == from.x)) continue;
      if (power[y][x] == max_p) {
        longest_att = min(longest_att, att_t[y][x]);
      }
    }
  }
  // 가장 큰 공격력 && 가장 오래된 공격 포탑 중에서 행과 열 합 가장 작은 포탑 찾기
  int min_rc_sum = INF;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      if (power[y][x] <= 0 || (y == from.y && x == from.x)) continue;
      if (power[y][x] == max_p && att_t[y][x] == longest_att) {
        min_rc_sum = min(min_rc_sum, rc_sum[y][x]);
      }
    }
  }
  // 작은 열부터 탐색하며 조건 만족하는 포탑 저장하고 종료
  for (int x = 0; x < M; ++x) {
    for (int y = 0; y < N; ++y) {
      if (power[y][x] <= 0 || (y == from.y && x == from.x)) continue;
      if (power[y][x] == max_p && att_t[y][x] == longest_att && rc_sum[y][x] == min_rc_sum) {
        to = { y, x };
        return;
      }
    }
  }
}

void choose_atk() {
  // 가장 작은 공격력 찾기
  int min_p = INF;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      if (power[y][x] <= 0) continue;
      min_p = min(min_p, power[y][x]);
    }
  }
  // 가장 작은 공격력 중에서 가장 최근 공격 포탑 찾기
  int recent_att = 0;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      if (power[y][x] <= 0) continue;
      if (power[y][x] == min_p) {
        recent_att = max(recent_att, att_t[y][x]);
      }
    }
  }
  // 가장 작은 공격력 && 가장 최근 공격 포탑 중에서 행과 열 합 가장 큰 포탑 찾기
  int max_rc_sum = 0;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      if (power[y][x] <= 0) continue;
      if (power[y][x] == min_p && att_t[y][x] == recent_att) {
        max_rc_sum = max(max_rc_sum, rc_sum[y][x]);
      }
    }
  }
  // 큰 열부터 탐색하며 조건 만족하는 포탑 저장
  for (int x = M - 1; x >= 0; --x) {
    for (int y = 0; y < N; ++y) {
      if (power[y][x] <= 0) continue;
      if (power[y][x] == min_p && att_t[y][x] == recent_att && rc_sum[y][x] == max_rc_sum) {
        from = { y, x };
        return;
      }
    }
  }
}

void input() {
  cin >> N >> M >> K;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      cin >> power[y][x];
      if (power[y][x] > 0) {
        ++tower_cnt;
      }
      rc_sum[y][x] = y + x;
    }
  }
}

void print() {
  cout << endl;
  cout << from.y << "," << from.x << endl;
  cout << to.y << "," << to.x << endl;
  cout << endl;
  for (int y = 0; y < N; ++y) {
    for (int x = 0; x < M; ++x) {
      cout << power[y][x] << ' ';
    }
    cout << endl;
  }
}
```
</details>

### 설명
bfs + 구현

2차원 배열에서의 bfs. -> struct Pos {int y, x; }; 활용.

종료 조건 (타워 1개 되면 종료) 을 꼭 확인하자.

A 조건 -> 2개 이상시 B 조건 -> 2개 이상시 C 조건 -> 특정 방향

위의 형태로 조건을 만족하는 후보를 찾을 때에는,

1. A조건의 값을 찾고,

2. A조건의 값을 갖는 후보들 중에서 B조건을 찾고,

3. A조건과 B조건 값을 갖는 후보들 중에서 C조건을 찾고,

4. 특정 방향으로 순회하며 처음으로 A,B,C 조건 값을 갖는 후보를 찾으면 된다.

***

## 2023 상반기 오전 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2023 상반기 오후 1번 : 메이즈 러너
> https://www.codetree.ai/ko/frequent-problems/problems/maze-runner/description?introductionSetId=&bookmarkId=

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <cmath>
using namespace std;

void print(int t);

const int dy[4] = { -1, 1, 0, 0 }, dx[4] = { 0, 0, -1, 1 };
struct Pos { int y, x; };

int N, M, K, board[10][10], tmp[10][10], sy, sx, sr, dis_sum;
vector<Pos> people;
Pos exit_pos;
void input();

void choose_square();
bool is_inside(int y, int x, int r, Pos p);

void move_person(int p);
int get_dist(Pos pos);

void rotate();
void rotate_pos(Pos& pos);
void rotate_arr();

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	input();

	for (int turn = 1; turn <= K; ++turn) {
		// 1. 사람 이동
		for (int p = 0; p < M; ++p) {
			move_person(p);
		}
		// 2. 출구 도착한 사람 제거
		vector<Pos> tmp;
		for (int p = 0; p < M; ++p) {
			if (people[p].y == exit_pos.y && people[p].x == exit_pos.x) continue;
			tmp.push_back(people[p]);
		}
		people = tmp;
		M = people.size();
		if (M == 0) break;
		// 3. 정사각형 선택
		choose_square();
		// 4. 보드 & 사람 회전 & 내구도 깎기
		rotate();
	}

	cout << dis_sum << '\n';
	cout << (exit_pos.y + 1) << ' ' << (exit_pos.x + 1);

	return 0;
}

void rotate() {
	// 사람 회전
	for (int p = 0; p < M; ++p) {
		if (is_inside(sy, sx, sr, people[p])) {
			rotate_pos(people[p]);
		}
	}
	// 출구 회전
	rotate_pos(exit_pos);
	// board 회전
	rotate_arr();
	// 내구도 깎기
	for (int i = 0; i < sr; ++i) {
		for (int j = 0; j < sr; ++j) {
			if (board[sy + i][sx + j]) {
				--board[sy + i][sx + j];
			}
		}
	}
}

void rotate_arr() {
	for (int i = 0; i < sr; ++i) {
		for (int j = 0; j < sr; ++j) {
			tmp[sy + j][sx + sr - 1 - i] = board[sy + i][sx + j];
		}
	}
	for (int i = 0; i < sr; ++i) {
		for (int j = 0; j < sr; ++j) {
			board[sy + i][sx + j] = tmp[sy + i][sx + j];
		}
	}
}

void rotate_pos(Pos& pos) {
	int i = pos.y - sy, j = pos.x - sx;
	pos.y = sy + j; pos.x = sx + sr - 1 - i;
}

void move_person(int p) {
	int dist = get_dist(people[p]);
	for (int d = 0; d < 4; ++d) {
		int yy = people[p].y + dy[d], xx = people[p].x + dx[d];
		if (yy < 0 || yy >= N || xx < 0 || xx >= N || board[yy][xx]) continue;
		if (get_dist({ yy, xx }) < dist) {
			people[p] = { yy, xx };
			++dis_sum;
			return;
		}
	}
}

int get_dist(Pos pos) {
	return abs(pos.y - exit_pos.y) + abs(pos.x - exit_pos.x);
}

bool is_inside(int y, int x, int r, Pos p) {
	return (y <= p.y && p.y < y + r && x <= p.x && p.x < x + r);
}

void choose_square() {
	for (int r = 1; r <= N; ++r) {
		for (int y = 0; y <= N - r; ++y) {
			for (int x = 0; x <= N - r; ++x) {
				if (!is_inside(y, x, r, exit_pos)) continue;
				for (int i = 0; i < M; ++i) {
					if (is_inside(y, x, r, people[i])) {
						sy = y; sx = x; sr = r;
						return;
					}
				}
			}
		}
	}
}

void input() {
	cin >> N >> M >> K;
	for (int y = 0; y < N; ++y) {
		for (int x = 0; x < N; ++x) {
			cin >> board[y][x];
		}
	}
	people.resize(M);
	for (int i = 0; i < M; ++i) {
		cin >> people[i].y >> people[i].x;
		--people[i].y; --people[i].x;
	}
	cin >> exit_pos.y >> exit_pos.x;
	--exit_pos.y; --exit_pos.x;
}

void print(int t) {
	cout << endl << t << endl;
	for (int p = 0; p < M; ++p) {
		cout << people[p].y << ", " << people[p].x << endl;
	}
	cout << "exit: " << exit_pos.y << ", " << exit_pos.x << endl;
	cout << "square: " << sy << ", " << sx << ", " << sr << endl << endl;
	for (int y = 0; y < N; ++y) {
		for (int x = 0; x < N; ++x) {
			cout << board[y][x] << ' ';
		}
		cout << endl;
	}
}
```
</details>

### 설명
bfs + 구현 문제

1. 가능한 모든 정사각형을 다 확인하여도 미로 크기가 작고, 참가자 수가 적어 시간안에 돌아간다.
<br>
2. 격자 내부에서 시계방향 회전 시키는 방법.

   2.1 기준이 되는 (y, x) 로부터 인덱스 (i, j) 를 구한다.
   2.2 tmp[j][r - 1 - i] = board[i][j]; 형태를 먼저 완성한다.
   2.3 tmp[y + j][x + r - 1 - i] = board[y + i][x + j] 형태로 바꾸어 준다.
<br>
3. 종료 조건 꼭 확인해야 한다. (모든 참가자가 탈출에 성공하면 게임 종료)
***

## 2023 상반기 오후 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2022 하반기 오전 1번 : 싸움땅
> https://www.codetree.ai/ko/frequent-problems/problems/battle-ground/description?introductionSetId=&bookmarkId=

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;

void print();

const int dy[4] = { -1, 0, 1, 0 }, dx[4] = { 0, 1, 0, -1 };
struct Player {
  int y, x, d, level, gun;
};

Player players[31];
int n, m, k, player_board[20][20], score[31];
priority_queue<int> guns[20][20];
void input();

// 플레이어 한 칸 이동. 이동한 칸에 플레이어 유무 반환
bool move_player(int num);

void get_gun(int num);

void fight(int num1, int num2);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();

  for (int turn = 0; turn < k; ++turn) {
    for (int num = 1; num <= m; ++num) {
      // 플레이어 순차적으로 한 칸 이동
      if (!move_player(num)) { // 이동한 곳에 플레이어 없는 경우
        player_board[players[num].y][players[num].x] = num;
        // 이동한 곳에서 총 획득
        get_gun(num);
      }
      else { // 이동한 곳에 플레이어 있는 경우
        fight(num, player_board[players[num].y][players[num].x]);
      }
    }
  }

  for (int num = 1; num <= m; ++num) {
    cout << score[num] << ' ';
  }

  return 0;
}

void fight(int num1, int num2) {
  Player& p1 = players[num1];
  Player& p2 = players[num2];

  // 1. 이동한 플레이어 승리 && 기존 플레이어 패배
  if (p1.level + p1.gun > p2.level + p2.gun || ((p1.level + p1.gun == p2.level + p2.gun) && p1.level > p2.level)) {
    // 점수 획득
    score[num1] += (p1.level + p1.gun - p2.level - p2.gun);
    // board 갱신
    player_board[p1.y][p1.x] = num1;
    // 패배 플레이어 총 격자에 내려놓기
    if (p2.gun > 0) {
      guns[p2.y][p2.x].push(p2.gun);
    }
    p2.gun = 0;
    // 패배 플레이어 칸 이동
    for (int i = 0; i < 4; ++i) {
      int yy = p2.y + dy[p2.d], xx = p2.x + dx[p2.d];
      if (0 <= yy && yy < n && 0 <= xx && xx < n && player_board[yy][xx] == 0) {
        player_board[yy][xx] = num2;
        p2.y = yy; p2.x = xx;
        break;
      }
      else {
        p2.d = (p2.d + 1) % 4;
      }
    }
    // 패배 플레이어 총 획득
    get_gun(num2);
    // 승리 플레이어 총 획득
    get_gun(num1);
  }
  // 2. 이동한 플레이어 패배 && 기존 플레이어 승리
  else {
    // 점수 획득
    score[num2] += (p2.level + p2.gun - p1.level - p1.gun);
    // 패배 플레이어 총 격자에 내려놓기
    if (p1.gun > 0) {
      guns[p1.y][p1.x].push(p1.gun);
    }
    p1.gun = 0;
    // 패배 플레이어 칸 이동
    for (int i = 0; i < 4; ++i) {
      int yy = p1.y + dy[p1.d], xx = p1.x + dx[p1.d];
      if (0 <= yy && yy < n && 0 <= xx && xx < n && player_board[yy][xx] == 0) {
        player_board[yy][xx] = num1;
        p1.y = yy; p1.x = xx;
        break;
      }
      else {
        p1.d = (p1.d + 1) % 4;
      }
    }
    // 패배 플레이어 총 획득
    get_gun(num1);
    // 승리 플레이어 총 획득
    get_gun(num2);
  }
}

void get_gun(int num) {
  Player& p = players[num];
  if (!guns[p.y][p.x].empty() && guns[p.y][p.x].top() > p.gun) {
    int bef_gun = p.gun;
    p.gun = guns[p.y][p.x].top();
    guns[p.y][p.x].pop();
    if (bef_gun > 0) {
      guns[p.y][p.x].push(bef_gun);
    }
  }
}

bool move_player(int num) {
  Player& p = players[num];
  int yy = p.y + dy[p.d], xx = p.x + dx[p.d];
  if (yy < 0 || yy >= n || xx < 0 || xx >= n) {
    p.d = (p.d + 2) % 4;
    yy = p.y + dy[p.d]; xx = p.x + dx[p.d];
  }
  player_board[p.y][p.x] = 0;
  p.y = yy; p.x = xx;
  return player_board[yy][xx] > 0;
}

void input() {
  cin >> n >> m >> k;
  for (int y = 0; y < n; ++y) {
    for (int x = 0; x < n; ++x) {
      int gun; cin >> gun;
      guns[y][x].push(gun);
    }
  }

  for (int num = 1; num <= m; ++num) {
    int y, x, d, s;
    cin >> y >> x >> d >> s;
    players[num] = { y - 1, x - 1, d, s, 0 };
    player_board[y - 1][x - 1] = num;
  }
}

void print() {
  cout << endl;
  for (int y = 0; y < n; ++y) {
    for (int x = 0; x < n; ++x) {
      cout << player_board[y][x] << ' ';
    }
    cout << endl;
  }
  for (int num = 1; num <= m; ++num) {
    cout << "player " << num << " : " << players[num].gun << endl;
  }
}
```
</details>

### 설명
종이에 변수 이름, n, m, k 의 의미 등을 적어놓고 코드를 짜면 왔다갔다 하지 않아도 되어 효율이 올라간다.

시험장에서 꼭 적으면서 하자.

***

## 2022 하반기 오전 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2022 하반기 오후 1번 : 코드트리 빵
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-mon-bread/description?introductionSetId=&bookmarkId=

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;

#define INF 987654321

const int dy[4] = { -1, 0, 0, 1 }, dx[4] = { 0, -1, 1, 0 };
struct Pos {
  int y, x;
  bool operator<(const Pos& rhs) const {
    if (y != rhs.y) return y < rhs.y;
    return x < rhs.x;
  }
  bool operator==(const Pos& rhs) const {
    return (y == rhs.y && x == rhs.x);
  }
  bool operator!=(const Pos& rhs) const {
    return !(y == rhs.y && x == rhs.x);
  }
};

int n, m, arrived_cnt;
vector<Pos> basecamps, wanted_conv, people;
bool can_go[15][15];
void input();

void move_to_basecamp(int i);
void move_person(int p);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();

  for (int t = 0; ; ++t) {
    // 1. 격자에 있는 사람들 이동
    for (int i = 0; i < people.size(); ++i) {
      if (people[i] == wanted_conv[i]) continue;
      move_person(i);
    }

    if (arrived_cnt == m) {
      cout << (t + 1);
      return 0;
    }

    // 2. 편의점에 도착한 사람 있다면, 해당 칸 지나갈 수 없게 처리
    for (int i = 0; i < people.size(); ++i) {
      if (people[i] == wanted_conv[i]) {
        can_go[people[i].y][people[i].x] = false;
      }
    }

    // 3. t번 사람 가고싶은 편의점과 가장 가까운 베이스 캠프 이동
    if (t < m) {
      move_to_basecamp(t);
      can_go[people.back().y][people.back().x] = false;
    }
  }

  return 0;
}

void move_person(int p) {
  Pos& psn = people[p];
  vector<vector<bool>> discovered(n, vector<bool>(n, false));
  vector<vector<Pos>> parent(n, vector<Pos>(n));
  queue<Pos> q;

  discovered[psn.y][psn.x] = true;
  q.push({ psn.y, psn.x });

  while (!q.empty()) {
    Pos here = q.front(); q.pop();
    for (int d = 0; d < 4; ++d) {
      int yy = here.y + dy[d], xx = here.x + dx[d];
      if (yy < 0 || yy >= n || xx < 0 || xx >= n) continue;
      if (discovered[yy][xx] || !can_go[yy][xx]) continue;
      discovered[yy][xx] = true;
      parent[yy][xx] = here;
      q.push({ yy, xx });
    }
  }

  Pos t = wanted_conv[p];
  while (parent[t.y][t.x] != psn) {
    t = parent[t.y][t.x];
  }

  psn = t;
  if (psn == wanted_conv[p]) {
    ++arrived_cnt;
  }
}

void move_to_basecamp(int i) {
  Pos& conv = wanted_conv[i];
  vector<vector<int>> dist(n, vector<int>(n, INF));
  queue<Pos> q;

  dist[conv.y][conv.x] = 0;
  q.push(conv);

  while (!q.empty()) {
    Pos here = q.front(); q.pop();
    for (int d = 0; d < 4; ++d) {
      int yy = here.y + dy[d], xx = here.x + dx[d];
      if (yy < 0 || yy >= n || xx < 0 || xx >= n) continue;
      if (dist[yy][xx] != INF || !can_go[yy][xx]) continue;
      dist[yy][xx] = dist[here.y][here.x] + 1;
      q.push({ yy, xx });
    }
  }

  int min_dist = INF, yy, xx;
  for (Pos& p : basecamps) {
    if (!can_go[p.y][p.x]) continue;
    if (min_dist > dist[p.y][p.x]) {
      min_dist = dist[p.y][p.x];
      yy = p.y; xx = p.x;
    }
  }

  people.push_back({ yy, xx });
  can_go[yy][xx] = false;
}

void input() {
  cin >> n >> m;

  for (int y = 0; y < n; ++y) {
    for (int x = 0; x < n; ++x) {
      int i; cin >> i;
      if (i == 1) {
        basecamps.push_back({ y, x });
      }
    }
  }
  sort(basecamps.begin(), basecamps.end());

  wanted_conv.resize(m);
  for (int i = 0; i < m; ++i) {
    cin >> wanted_conv[i].y >> wanted_conv[i].x;
    --wanted_conv[i].y;
    --wanted_conv[i].x;
  }

  memset(can_go, true, sizeof(can_go));
}
```
</details>

### 설명
매 반복마다 사람들이 최단경로 위에서 한 칸 움직여야 하는 문제.

매 반복마다 bfs를 수행하고, 경로를 저장하여 움직이면 된다.

최단경로가 여러가지라면, 상, 좌, 우, 하 의 우선순위로 움직여야하는데, 이와 같은 경우에는 주어진 순서대로 bfs 탐색을 수행하면 된다.

두 최단경로가 있을 때, 처음으로 경로가 달라지는 부분을 생각해보자.

이 경우에 우선순위가 높은 경로가 먼저 들어가게 되고, 이후 탐색부터 항상 먼저 큐에서 꺼내진다.

따라서 마지막 목적지는 큐에서 먼저 꺼내지는 우선순위가 높은 경로에 의해 발견되게 된다.

**격자에 있는 사람들이 모두 이동한 뒤에 이동 불가한 칸을 체크해주어야 한다.**

***

## 2022 하반기 오후 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***