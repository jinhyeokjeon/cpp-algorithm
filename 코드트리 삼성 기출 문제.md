## 2024 하반기 오전 1번 : 미지의 공간 탈출
> https://www.codetree.ai/ko/frequent-problems/problems/escape-unknown-space/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int dy[8] = { -1, 0, 1, 0, -1, 1, 1, -1 }, dx[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };
struct Pos {
    int y, x, faint;
    bool out;
    bool operator<(const Pos& rhs) const {
        if (y != rhs.y) return y > rhs.y;
        return x > rhs.x;
    }
};
int N, M, P, C, D, r_y, r_x, santa_cnt;
int board[50][50];
vector<Pos> santa;
vector<int> score;
void input();

int get_dist(int y0, int x0, int y1, int x1);

void move_rudolf();
void move_santa(int s);
void push_santa(int y, int x, int d);

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    input();

    for (int turn = 0; turn < M; ++turn) {
        // 1. 루돌프의 움직임
        move_rudolf();
        if (santa_cnt == 0) break;

        // 2. 산타의 움직임
        for (int s = 1; s <= P; ++s) {
            if (santa[s].out || santa[s].faint > 0) continue;
            move_santa(s);
        }
        if (santa_cnt == 0) break;

        // 3. 기절 시간 줄이기 && 탈락 안한 산타 1점 추가
        for (int s = 1; s <= P; ++s) {
            if (santa[s].out) continue;
            if (santa[s].faint > 0) {
                --santa[s].faint;
            }
            ++score[s];
        }
    }

    for (int s = 1; s <= P; ++s) {
        cout << score[s] << ' ';
    }

    return 0;
}

void move_santa(int s) {
    int dist, c_y = -1, c_x, c_d;
    int y = santa[s].y, x = santa[s].x;
    int min_dist = get_dist(y, x, r_y, r_x);

    // 이동할 좌표 찾기
    for (int d = 0; d < 4; ++d) {
        int yy = y + dy[d], xx = x + dx[d];
        if (yy < 0 || yy >= N || xx < 0 || xx >= N || board[yy][xx] != 0) continue;
        dist = get_dist(yy, xx, r_y, r_x);
        if (dist < min_dist) {
            min_dist = dist;
            c_y = yy; c_x = xx; c_d = d;
        }
    }

    if (c_y == -1) return;

    // 산타 이동
    board[y][x] = 0;
    board[c_y][c_x] = s;
    santa[s].y = c_y; santa[s].x = c_x;

    // 충돌 처리
    c_d = (c_d + 2) % 4;
    if (c_y == r_y && c_x == r_x) {
        score[s] += D;
        int yy = c_y + dy[c_d] * D, xx = c_x + dx[c_d] * D;
        if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
            board[c_y][c_x] = 0;
            santa[s].out = true;
            --santa_cnt;
        }
        else {
            if (board[yy][xx] != 0) {
                push_santa(yy, xx, c_d);
            }
            board[c_y][c_x] = 0;
            board[yy][xx] = s;
            santa[s].y = yy; santa[s].x = xx;
            santa[s].faint = 2;
        }
    }
}

void push_santa(int y, int x, int d) {
    int s = board[y][x];
    int yy = y + dy[d], xx = x + dx[d];
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
        santa[s].out = true;
        board[y][x] = 0;
        --santa_cnt;
        return;
    }
    if (board[yy][xx] != 0) {
        push_santa(yy, xx, d);
    }
    santa[s].y = yy; santa[s].x = xx;
    board[yy][xx] = board[y][x];
    board[y][x] = 0;
}

void move_rudolf() {
    vector<Pos> s_santa = santa;
    int dist, min_dist = 987654321, s_y, s_x;
    sort(s_santa.begin() + 1, s_santa.end());

    // 가장 가까운 산타의 좌표 찾기
    for (int s = 1; s <= P; ++s) {
        if (s_santa[s].out) continue;
        dist = get_dist(r_y, r_x, s_santa[s].y, s_santa[s].x);
        if (dist < min_dist) {
            min_dist = dist;
            s_y = s_santa[s].y; s_x = s_santa[s].x;
        }
    }

    min_dist = 987654321;
    int c_y, c_x, c_d;
    // (y, x)에 위치한 산타와 가장 가까운 방향으로 돌진
    for (int d = 0; d < 8; ++d) {
        int yy = r_y + dy[d], xx = r_x + dx[d];
        if (yy < 0 || yy >= N || xx < 0 || xx >= N) continue;
        dist = get_dist(s_y, s_x, yy, xx);
        if (dist < min_dist) {
            min_dist = dist;
            c_y = yy; c_x = xx; c_d = d;
        }
    }
    r_y = c_y; r_x = c_x;

    // 충돌 있다면 충돌
    if (board[r_y][r_x] != 0) {
        int s = board[r_y][r_x];
        score[s] += C;
        int yy = r_y + dy[c_d] * C, xx = r_x + dx[c_d] * C;
        if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
            board[r_y][r_x] = 0;
            santa[s].out = true;
            --santa_cnt;
        }
        else {
            if (board[yy][xx] != 0) {
                push_santa(yy, xx, c_d);
            }
            board[r_y][r_x] = 0;
            board[yy][xx] = s;
            santa[s].y = yy; santa[s].x = xx;
            santa[s].faint = 2;
        }
    }
}

int get_dist(int y0, int x0, int y1, int x1) {
    return (y0 - y1) * (y0 - y1) + (x0 - x1) * (x0 - x1);
}

void input() {
    cin >> N >> M >> P >> C >> D;
    cin >> r_y >> r_x;
    santa_cnt = P;
    --r_y; --r_x;
    santa.resize(P + 1);
    score.resize(P + 1, 0);
    for (int i = 0; i < P; ++i) {
        int p, y, x;
        cin >> p >> y >> x;
        santa[p] = { y - 1, x - 1, 0, false };
        board[y - 1][x - 1] = p;
    }
}

```
</details>

### 설명
 if (there.y < 0 || there.y >= 3 * M || there.x < 0 || there.x >= 3 * M) continue;
 이 부분에서 y y x x 순서로 제대로 했는지 꼭 확인하자.

 Pos get_there(Pos here, int d);
 0 1 2 3 이 0 1 2 3 과 만나는 것이 아니다.
 0 1 2 3 이 3 2 1 0 이렇게 만나는 경우도 반드시 생각하자.

***

## 2024 하반기 오전 2번 : 코드트리 DB
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-db/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
using namespace std;

struct Node {
  int left = 0, right = 0, count = 0;
  long long sum = 0;
};
vector<Node> tree;
void update(int node, int nl, int nr, int val, int count, int sum);
int query_rank(int node, int nl, int nr, int k);
long long query_sum(int node, int nl, int nr, int l, int r);

map<string, int> name_value;
map<int, string> value_name;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  string query_type, name;
  int Q, value, k;

  cin >> Q;
  while (Q--) {
    cin >> query_type;
    if (query_type == "init") {
      name_value.clear();
      value_name.clear();
      tree.clear();

      tree.push_back(Node());
      tree.push_back(Node());
    }
    else if (query_type == "insert") {
      cin >> name >> value;
      if (name_value.count(name) || value_name.count(value)) {
        cout << "0\n";
      }
      else {
        name_value[name] = value;
        value_name[value] = name;
        update(1, 1, 1e9, value, 1, value);
        cout << "1\n";
      }
    }
    else if (query_type == "delete") {
      cin >> name;
      if (name_value.count(name) == 0) {
        cout << "0\n";
      }
      else {
        int value = name_value[name];
        name_value.erase(name);
        value_name.erase(value);
        update(1, 1, 1e9, value, 0, 0);
        cout << value << '\n';
      }
    }
    else if (query_type == "rank") {
      cin >> k;
      if (tree[1].count < k) {
        cout << "None\n";
      }
      else {
        cout << value_name[query_rank(1, 1, 1e9, k)] << '\n';
      }
    }
    else if (query_type == "sum") {
      cin >> k;
      long long sum = query_sum(1, 1, 1e9, 1, k);
      cout << sum << '\n';
    }
  }
}

void update(int node, int nl, int nr, int val, int count, int sum) {
  if (val < nl || nr < val) return;
  if (nl == nr) {
    tree[node].count = count;
    tree[node].sum = sum;
    return;
  }
  int nm = (nl + nr) / 2;
  if (val <= nm) {
    if (tree[node].left == 0) {
      tree[node].left = tree.size();
      tree.push_back(Node());
    }
    update(tree[node].left, nl, nm, val, count, sum);
  }
  else {
    if (tree[node].right == 0) {
      tree[node].right = tree.size();
      tree.push_back(Node());
    }
    update(tree[node].right, nm + 1, nr, val, count, sum);
  }
  tree[node].count = tree[tree[node].left].count + tree[tree[node].right].count;
  tree[node].sum = tree[tree[node].left].sum + tree[tree[node].right].sum;
  return;
}

int query_rank(int node, int nl, int nr, int k) {
  if (nl == nr) return nl;
  int nm = (nl + nr) / 2;

  if (tree[tree[node].left].count >= k) {
    return query_rank(tree[node].left, nl, nm, k);
  }
  else {
    return query_rank(tree[node].right, nm + 1, nr, k - tree[tree[node].left].count);
  }
}

long long query_sum(int node, int nl, int nr, int l, int r) {
  if (r < nl || nr < l) return 0;
  if (l <= nl && nr <= r) return tree[node].sum;
  int nm = (nl + nr) / 2;
  long long ret = 0;
  if (tree[node].left) {
    ret += query_sum(tree[node].left, nl, nm, l, r);
  }
  if (tree[node].right) {
    ret += query_sum(tree[node].right, nm + 1, nr, l, r);
  }
  return ret;
}
```
</details>

### 설명
다이나믹 세그먼트 트리

일반적인 세그먼트 트리처럼 정해진 범위에 대해 모든 노드를 다 만드는 것이 아닌, 필요한 노드가 생길 때마다 노드를 동적으로 추가한다.

각 노드에 범위의 크기, 범위의 합, 왼쪽 노드 인덱스, 오른쪽 노드 인덱스를 갖도록 하고, update 연산이 주어질 때마다 노드를 추가한다.

이 문제에서는 1 ~ 10억 의 범위의 다이나믹 세그먼트 트리를 다루며, log(10억) = 32 이하이므로 한 번 update 마다 32 이하의 노드가 생기며, 한번의 쿼리도 O(32) 의 시간복잡도를 갖는다.

***

## 2024 하반기 오후 1번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2024 하반기 오후 2번 : 코드트리 등산 게임
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-mountain-climbing-games/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int Q, n, h, order_type;
vector<int> idx;
vector<vector<int>> mount;

bool cmp(const vector<int>& vec, int v) {
  return vec.back() < v;
}

void insert(int h) {
  /*
  int l = 0, r = mount.size();
  while (l < r) {
    int m = (l + r) / 2;
    if (mount[m].back() < h) {
      l = m + 1;
    }
    else {
      r = m;
    }
  }
  if (r == mount.size()) {
    mount.push_back(vector<int>(1, h));
  }
  else {
    mount[l].push_back(h);
  }
  idx.push_back(l);
  */

  auto it = lower_bound(mount.begin(), mount.end(), h, cmp);
  if (it == mount.end()) {
    idx.push_back(mount.size());
    mount.push_back(vector<int>(1, h));
  }
  else {
    idx.push_back(it - mount.begin());
    it->push_back(h);
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cin >> Q;
  while (Q--) {
    cin >> order_type;
    if (order_type == 100) {
      cin >> n;
      for (int i = 0; i < n; ++i) {
        cin >> h;
        insert(h);
      }
    }
    else if (order_type == 200) {
      cin >> h;
      insert(h);

    }
    else if (order_type == 300) {
      mount[idx.back()].pop_back();
      if (mount.back().empty()) {
        mount.pop_back();
      }
      idx.pop_back();
    }
    else if (order_type == 400) {
      int m_idx; cin >> m_idx; --m_idx;
      long long score = 1000000;
      score *= (idx[m_idx] + mount.size());
      score += mount.back().front();;
      printf("%lld\n", score);
    }
  }
  return 0;
}
```
</details>

### 설명
LIS(Longest Increasing Subsequence) 를 활용하는 문제.

알려진 해법과 다른 점은, 지우는 경우도 있으므로 vector<int> 가 아닌

vector<vector<int>> 로 지우는 것이 아니라 back 에 추가하는 방식을 사용한다.

다음은 lower_bound 에 사용자 정의 기준 함수 넣는 방법이다.

lower_bound(first, end, value, comp);

bool comp(element, value);

형태이다.

***

## 2024 상반기 오전 1번: 고대 문명 유적 탐사
> https://www.codetree.ai/ko/frequent-problems/problems/ancient-ruin-exploration/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int dy[4] = { -1, 1, 0, 0 }, dx[4] = { 0, 0, -1, 1 };
struct Pos { int y, x; };
struct Info {
  int board[5][5];
  void rotate(int y, int x, int t);
};

int K, M, wall_num[300], wall_idx;
bool discovered[5][5];
Info info;
void input();

Pos cand; int cand_d;
bool get_max_gold();
int get_value_1(int y, int x, int d);
int clear_gold(int (*board)[5]);

void fill_gold();

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();
  for (int turn = 0; turn < K; ++turn) {
    // 1. 유적 획득 가치 최대 좌표, 회전 횟수 구하기
    if (!get_max_gold()) {
      break;
    }
    // 2. 최대 유물 1차 획득할 수 있도록 회전
    info.rotate(cand.y, cand.x, cand_d);
    // 3. 유물 연쇄 획득 과정 수행
    int v_sum = 0;
    while (true) {
      // 1. 유물 사라지기
      int v = clear_gold(info.board);
      if (v == 0) break;
      v_sum += v;
      // 2. 유물 채우기
      fill_gold();
    }
    cout << v_sum << ' ';
  }
  return 0;
}

void fill_gold() {
  for (int x = 0; x < 5; ++x) {
    for (int y = 4; y >= 0; --y) {
      if (info.board[y][x] == 0) {
        info.board[y][x] = wall_num[wall_idx++];
      }
    }
  }
}

bool get_max_gold() {
  int max_val = 0; // 최대 획득 가치
  int value[3][3][4]; // y, x, 회전횟수

  for (int d = 1; d <= 3; ++d) {
    for (int x = 0; x < 3; ++x) {
      for (int y = 0; y < 3; ++y) {
        value[y][x][d] = get_value_1(y, x, d);
        max_val = max(max_val, value[y][x][d]);
      }
    }
  }

  if (max_val == 0) return false;

  for (int d = 1; d <= 3; ++d) {
    for (int x = 0; x < 3; ++x) {
      for (int y = 0; y < 3; ++y) {
        if (value[y][x][d] == max_val) {
          cand = { y, x };
          cand_d = d;
          return true;
        }
      }
    }
  }

  return true;
}

int get_value_1(int y, int x, int d) {
  Info tmp = info;
  tmp.rotate(y, x, d);
  return clear_gold(tmp.board);
}

int clear_gold(int (*board)[5]) {
  memset(discovered, false, sizeof(discovered));
  int ret = 0;

  for (int y = 0; y < 5; ++y) {
    for (int x = 0; x < 5; ++x) {
      if (!discovered[y][x]) {
        queue<Pos> q;
        vector<Pos> v;
        discovered[y][x] = true;
        q.push({ y, x });
        while (!q.empty()) {
          Pos here = q.front(); q.pop();
          v.push_back(here);
          for (int d = 0; d < 4; ++d) {
            int yy = here.y + dy[d], xx = here.x + dx[d];
            if (yy < 0 || yy >= 5 || xx < 0 || xx >= 5) continue;
            if (!discovered[yy][xx] && board[here.y][here.x] == board[yy][xx]) {
              discovered[yy][xx] = true;
              q.push({ yy, xx });
            }
          }
        }
        if (v.size() >= 3) {
          ret += v.size();
          for (Pos& p : v) {
            board[p.y][p.x] = 0;
          }
        }
      }
    }
  }

  return ret;
}

void Info::rotate(int y, int x, int t) {
  int tmp[5][5];
  while (t--) {
    memcpy(tmp, board, sizeof(board));
    for (int i = 0; i < 3; ++i) {
      for (int j = 0; j < 3; ++j) {
        tmp[y + j][x + 2 - i] = board[y + i][x + j];
      }
    }
    memcpy(board, tmp, sizeof(board));
  }
}

void input() {
  cin >> K >> M;
  for (int y = 0; y < 5; ++y) {
    for (int x = 0; x < 5; ++x) {
      cin >> info.board[y][x];
    }
  }
  for (int i = 0; i < M; ++i) {
    cin >> wall_num[i];
  }
}
```
</details>

### 설명
BFS 구현 문제

***

## 2024 상반기 오전 2번
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-tour/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

#define INF 987654321

struct Info {
  int revenue, dest;
  bool deleted;
  Info(int revenue, int dest, bool deleted) : revenue(revenue), dest(dest), deleted(deleted) {}
  Info() : deleted(false) {}
};

struct Info2 {
  int profit, id;
  bool operator<(const Info2& rhs) const {
    if (profit != rhs.profit) {
      return profit < rhs.profit;
    }
    return id > rhs.id;
  }
};

int Q, n, m, source;
vector<vector<pair<int, int>>> adj;
vector<int> dist;
void input();
void dijkstra();

Info products[30001];
priority_queue<Info2> ordered;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();
  while (Q--) {
    int order_type; cin >> order_type;
    // 여행 상품 생성
    if (order_type == 200) {
      int id, revenue, dest;
      cin >> id >> revenue >> dest;
      products[id] = { revenue, dest, false };
      ordered.push({ revenue - dist[dest], id });
    }
    // 여행 상품 취소
    else if (order_type == 300) {
      int id; cin >> id;
      if (!products[id].deleted) {
        products[id].deleted = true;
      }
    }
    // 최적의 여행 상품 판매
    else if (order_type == 400) {
      bool sell = false;
      while (!ordered.empty()) {
        Info2 info = ordered.top();
        if (products[info.id].deleted) {
          ordered.pop();
        }
        else if (info.profit < 0) {
          break;
        }
        else {
          cout << info.id << '\n';
          products[info.id].deleted = true;
          ordered.pop();
          sell = true;
          break;
        }
      }
      if (!sell) {
        cout << "-1\n";
      }
    }
    // 여행 상품의 출발지 변경
    else if (order_type == 500) {
      int s; cin >> s;
      source = s;
      dijkstra();
      priority_queue<Info2> tmp;
      while (!ordered.empty()) {
        Info2 i2 = ordered.top(); ordered.pop();
        if (products[i2.id].deleted) continue;
        Info& p = products[i2.id];
        tmp.push({ p.revenue - dist[p.dest], i2.id });
      }
      ordered = tmp;
    }
  }
  return 0;
}

void dijkstra() {
  dist = vector<int>(n, INF);
  priority_queue<pair<int, int>> pq;

  dist[source] = 0;
  pq.push({ -0, source });

  while (!pq.empty()) {
    int here = pq.top().second, cost = -pq.top().first; pq.pop();
    if (dist[here] < cost) continue;
    for (int i = 0; i < adj[here].size(); ++i) {
      int there = adj[here][i].first, next_cost = cost + adj[here][i].second;
      if (dist[there] > next_cost) {
        dist[there] = next_cost;
        pq.push({ -next_cost, there });
      }
    }
  }
}

void input() {
  cin >> Q;
  cin >> n; // 100 
  cin >> n >> m;
  adj.resize(n);
  int u, v, w;
  for (int i = 0; i < m; ++i) {
    cin >> u >> v >> w;
    adj[u].emplace_back(v, w);
    adj[v].emplace_back(u, w);
  }
  dijkstra();
  --Q;
}
```
</details>

다익스트라 + 우선순위 큐를 사용하는 문제.

다익스트라 알고리즘은 O(ElogE) 이지만, 출발지 변경이 최대 15번이므로 가능하다.

다익스트라 알고리즘은 '방향그래프' 기준이므로 무향그래프가 주어진다면, 무향 그래프의 무향 간선을 두개의 방향 간선으로 나누어 주어야 한다.

또한 다익스트라 알고리즘은 같은 정점들을 연결하는 간선들이 여러개 주어져도 상관 없다.

***

## 2024 상반기 오후 1번 : 마법의 숲 탐색
> https://www.codetree.ai/ko/frequent-problems/problems/magical-forest-exploration/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

const int dy[4] = { -1, 0, 1, 0 }, dx[4] = { 0, 1, 0, -1 };
struct Pos { int y, x, d; };
int R, C, K, board[73][70]; // 3칸 추가됨, 0: 빈칸, 1 ~ K: 골렘, K + 1 ~ K + K: 출구

const int down_y[3] = { 1, 2, 1 }, down_x[3] = { -1, 0, 1 };
const int left_y[5] = { -1, 0, 1, 1, 2 }, left_x[5] = { -1, -2, -1, -2, -1 };
const int right_y[5] = { -1, 0, 1, 1, 2 }, right_x[5] = { 1, 2, 1, 2, 1 };
Pos gol;

bool go_down();
bool go_left();
bool go_right();

int score;
bool discovered[73][70];
void move();

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cin >> R >> C >> K;
  R += 3; // 위쪽으로 세 칸 추가
  for (int num = 1; num <= K; ++num) {
    cin >> gol.x >> gol.d;
    --gol.x; gol.y = 1;
    // 골렘 이동
    while (true) {
      // 아래 이동 확인
      if (go_down()) {
        continue;
      }
      // 왼쪽 이동 확인
      else if (go_left()) {
        continue;
      }
      // 오른쪽 이동 확인
      else if (go_right()) {
        continue;
      }
      // 더 이상 이동 불가
      else {
        break;
      }
    }
    // 숲을 벗어난 상태
    if (gol.y < 4) {
      memset(board, 0, sizeof(board));
      continue;
    }
    // board에 추가
    for (int d = 0; d < 4; ++d) {
      if (d == gol.d) {
        board[gol.y + dy[d]][gol.x + dx[d]] = K + num;
      }
      else {
        board[gol.y + dy[d]][gol.x + dx[d]] = num;
      }
    }
    board[gol.y][gol.x] = num;
    // 7. 정령의 이동
    move();
  }
  cout << score;
  return 0;
}

void move() {
  memset(discovered, false, sizeof(discovered));
  queue<Pos> q;
  int ret = 0;

  discovered[gol.y][gol.x] = true;
  q.push({ gol.y, gol.x });

  while (!q.empty()) {
    Pos here = q.front(); q.pop();
    ret = max(ret, here.y - 2);
    for (int d = 0; d < 4; ++d) {
      int yy = here.y + dy[d], xx = here.x + dx[d];
      if (yy < 0 || yy >= R || xx < 0 || xx >= C || discovered[yy][xx] || board[yy][xx] == 0) continue;
      if (board[here.y][here.x] == board[yy][xx] || board[here.y][here.x] + K == board[yy][xx] || board[here.y][here.x] > K) {
        discovered[yy][xx] = true;
        q.push({ yy, xx });
      }
    }
  }
  score += ret;
}

bool go_right() {
  for (int i = 0; i < 5; ++i) {
    int yy = gol.y + right_y[i], xx = gol.x + right_x[i];
    if (yy < 0 || yy >= R || xx < 0 || xx >= C) return false;
    if (board[yy][xx] >= 1) return false;
  }
  gol.y += 1; gol.x += 1;
  gol.d = (gol.d + 1) % 4;
  return true;
}

bool go_left() {
  for (int i = 0; i < 5; ++i) {
    int yy = gol.y + left_y[i], xx = gol.x + left_x[i];
    if (yy < 0 || yy >= R || xx < 0 || xx >= C) return false;
    if (board[yy][xx] >= 1) return false;
  }
  gol.y += 1; gol.x -= 1;
  gol.d = (gol.d + 3) % 4;
  return true;
}

bool go_down() {
  for (int i = 0; i < 3; ++i) {
    int yy = gol.y + down_y[i], xx = gol.x + down_x[i];
    if (yy < 0 || yy >= R || xx < 0 || xx >= C) return false;
    if (board[yy][xx] >= 1) return false;
  }
  gol.y += 1;
  return true;
}
```
</details>

### 설명
복잡한 구현 문제

검사해야 하는 범위가 있다면, 해당 검사 범위에 해당하는 dy, dx를 미리 배열에 저장해 놓으면 쉽게 검사할 수 있다.

***

## 2024 상반기 오후 2번 : 색깔 트리
> https://www.codetree.ai/ko/frequent-problems/problems/color-tree/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Node {
  int color, depth, parent, created_t, color_t;
  vector<int> children;
};

int Q;
vector<int> root;
Node tree[100001];

bool check_d(int p, int d_limit);

int score;
int calc_value(int p, int c_color_t, int c_color);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  cin >> Q;
  for (int turn = 0; turn < Q; ++turn) {
    int q_type; cin >> q_type;
    // 노드 추가
    if (q_type == 100) {
      int m_id, p_id, color, depth;
      cin >> m_id >> p_id >> color >> depth;

      // 주어진 부모가 추가 안된 노드
      if (p_id != -1 && tree[p_id].parent == 0) continue;
      // 깊이 모순 확인
      if (p_id != -1 && !check_d(p_id, 2)) continue;
      // 노드 추가
      tree[m_id] = { color, depth, p_id, turn, -1 };
      if (p_id != -1) {
        tree[p_id].children.push_back(m_id);
      }
      else {
        root.push_back(m_id);
      }
    }
    // 색깔 변경. c_color에 색 기록.
    else if (q_type == 200) {
      int m_id, color;
      cin >> m_id >> color;
      tree[m_id].color = color;
      tree[m_id].color_t = turn;
    }
    // 부모를 타고 올라가며 color_t 값이 가장 큰 color 값으로 갱신
    else if (q_type == 300) {
      int m_id; cin >> m_id;

      // 추가 안된 노드일 경우 넘어감
      if (tree[m_id].parent == 0) continue;

      int color = tree[m_id].color;
      int p = m_id;
      int max_c_color_t = max(tree[m_id].created_t, tree[m_id].color_t);
      while (true) {
        if (tree[p].parent == -1) break;
        p = tree[p].parent;
        if (tree[p].color_t > max_c_color_t) {
          max_c_color_t = tree[p].color_t;
          color = tree[p].color;
        }
      }
      tree[m_id].color = color;
      cout << color << '\n';
    }
    else if (q_type == 400) {
      score = 0;
      for (int r : root) {
        calc_value(r, tree[r].color_t, tree[r].color);
      }
      cout << score << '\n';
    }
  }
}

int calc_value(int p, int color_t, int color) {
  int next_color_t = color_t, next_color = color;
  if (color_t < tree[p].color_t) {
    next_color_t = tree[p].color_t;
    next_color = tree[p].color;
  }

  if (color_t > max(tree[p].color_t, tree[p].created_t)) {
    tree[p].color = color;
  }

  int mask = (1 << tree[p].color);
  for (int c : tree[p].children) {
    mask |= calc_value(c, next_color_t, next_color);
  }

  int cnt = 0;
  for (int i = 1; i <= 5; ++i) {
    if (mask & (1 << i)) ++cnt;
  }
  score += cnt * cnt;

  return mask;
}

bool check_d(int p, int d_limit) {
  if (tree[p].depth < d_limit) return false;
  if (tree[p].parent != -1) {
    return check_d(tree[p].parent, d_limit + 1);
  }
  else {
    return true;
  }
}
```
</details>

### 설명
트리 문제.

어떤 노드를 루트로 하는 트리의 색을 변경할 때마다 탐색을 하며 색을 바꿔주면, 시간을 초과하게 된다.

이 문제에서의 힌트는 최대 깊이가 100 이하이므로, 트리의 루트까지 탐색하여 올라가는 과정이 O(100) 이라는 것이다.

즉 어떤 노드의 색을 조회할 때, 부모까지 타고 올라가며 해당 노드의 탄생 시간 이후, 또는 해당 노드의 색 변화 이후 변화된 색이 있다면 그 색으로 바꾸어주면 된다.

또한 모든 노드의 가치를 계산할 때에도 루트부터 가장 이후에 변화된 색과 시간을 전파하며 아래로 내려가며 계산한다.

***

## 2023 하반기 오전 1번 : 왕실의 기사 대결
> https://www.codetree.ai/ko/frequent-problems/problems/royal-knight-duel/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

const int dy[4] = { -1, 0, 1, 0 }, dx[4] = { 0, 1, 0, -1 };
struct Horse {
	int y, x, h, w, hp;
};
int L, N, Q, board[42][42], WALL;
bool attack[42][42];
vector<Horse> horses;
vector<int> attack_sum;

void input();

bool can_move(int i, int d);
bool check_horses(int y, int x, int h, int w, set<int>& sets);
void move_horses(int i, int d);
void damage(int num);

void print() {
	cout << endl;
	for (int i = 0; i <= L + 1; ++i) {
		for (int j = 0; j <= L + 1; ++j) {
			cout << board[i][j] << ' ';
		}
		cout << endl;
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	input();
	while (Q--) {
		int i, d;
		cin >> i >> d;
		if (horses[i].hp <= 0) continue;
		if (!can_move(i, d)) continue;
		move_horses(i, d);
		
	}
	int sum = 0;
	for (int i = 1; i <= N; ++i) {
		if (horses[i].hp > 0) {
			sum += attack_sum[i];
		}
	}
	cout << sum;

	return 0;
}

void damage(int num) {
	for (int i = 0; i < horses[num].h; ++i) {
		for (int j = 0; j < horses[num].w; ++j) {
			if (attack[horses[num].y + i][horses[num].x + j]) {
				--horses[num].hp;
				++attack_sum[num];
			}
		}
	}
	if (horses[num].hp <= 0) {
		for (int i = 0; i < horses[num].h; ++i) {
			for (int j = 0; j < horses[num].w; ++j) {
				board[horses[num].y + i][horses[num].x + j] = 0;
			}
		}
	}
}

void move_horses(int i, int d) {
	int yy = horses[i].y + dy[d], xx = horses[i].x + dx[d];
	set<int> sets;

	check_horses(yy, xx, horses[i].h, horses[i].w, sets);
	if (sets.count(i)) {
		sets.erase(i);
	}

	for (int i : sets) {
		move_horses(i, d);
		damage(i);
	}
	if (d == 0) { // 위쪽
		for (int x = 0; x < horses[i].w; ++x) {
			board[horses[i].y - 1][horses[i].x + x] = i;
			board[horses[i].y + horses[i].h - 1][horses[i].x + x] = 0;
		}
	}
	else if (d == 1) { // 오른쪽
		for (int y = 0; y < horses[i].h; ++y) {
			board[horses[i].y + y][horses[i].x + horses[i].w] = i;
			board[horses[i].y + y][horses[i].x] = 0;
		}
	}
	else if (d == 2) { // 아래쪽
		for (int x = 0; x < horses[i].w; ++x) {
			board[horses[i].y + horses[i].h][horses[i].x + x] = i;
			board[horses[i].y][horses[i].x + x] = 0;
		}
	}
	else if (d == 3) { // 왼쪽
		for (int y = 0; y < horses[i].h; ++y) {
			board[horses[i].y + y][horses[i].x - 1] = i;
			board[horses[i].y + y][horses[i].x + horses[i].w - 1] = 0;
		}
	}
	horses[i].y = yy; horses[i].x = xx;
}

// i번 말이 움직일 수 있는지 조사
bool can_move(int i, int d) {
	int yy = horses[i].y + dy[d], xx = horses[i].x + dx[d];

	// 1. 움직였을때 벽과 겹치는지, 겹치지 않는다면 겹치는 다른 말 구하기
	set<int> sets;
	if (!check_horses(yy, xx, horses[i].h, horses[i].w, sets)) {
		return false;
	}
	if (sets.count(i)) {
		sets.erase(i);
	}
	
	// 2. 움직였을 때 겹치는 다른 말이 움직일 수 있는지 조사
	for (int h : sets) {
		if (!can_move(h, d)) {
			return false;
		}
	}

	return true;
}

// 이동했을 때 겹치는 말 반환 && 벽과 겹치는지 조사
bool check_horses(int y, int x, int h, int w, set<int>& sets) {
	for (int i = 0; i < h; ++i) {
		for (int j = 0; j < w; ++j) {
			if (board[y + i][x + j] == WALL) {
				return false;
			}
			if (board[y + i][x + j] >= 1) {
				sets.insert(board[y + i][x + j]);
			}
		}
	}
	return true;
}

void input() {
	cin >> L >> N >> Q;
	WALL = N + 1;

	for (int y = 1; y <= L; ++y) {
		for (int x = 1; x <= L; ++x) {
			cin >> board[y][x];
			if (board[y][x] == 2) {
				board[y][x] = WALL;
			}
			else if (board[y][x] == 1) {
				board[y][x] = 0;
				attack[y][x] = true;
			}
		}
	}

	for (int i = 0; i <= L + 1; ++i) {
		board[0][i] = board[L + 1][i] = WALL;
		board[i][0] = board[i][L + 1] = WALL;
	}

	horses.resize(N + 1);
	attack_sum.resize(N + 1, 0);
	for (int i = 1; i <= N; ++i) {
		cin >> horses[i].y >> horses[i].x >> horses[i].h >> horses[i].w >> horses[i].hp;
		for (int a = 0; a < horses[i].h; ++a) {
			for (int b = 0; b < horses[i].w; ++b) {
				board[horses[i].y + a][horses[i].x + b] = i;
			}
		}
	}
}
```
</details>

### 설명
재귀함수를 이용하여 가장 나중에 밀려나는 기사부터 처리해나가는 문제.

이동시 겹치는 기사를 구할 때 자기 자신을 빼도록 해야 한다.

***

## 2023 하반기 오전 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2023 하반기 오후 1번 : 루돌프의 반란
> https://www.codetree.ai/ko/frequent-problems/problems/rudolph-rebellion/description

### 코드
<details>
<summary>C++</summary>

```cpp
// 문제 종료 조건 확인하기!!!!!!!!!!!!!!!
// 모든 산타가 게임에서 탈락하면 그 즉시 게임은 종료된다.

// board[y][x] 를 board[yy][xx] 로 옮길 때,
// board[y][x] = 0 을 먼저 하고 옮기는 실수 하지 않기.

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int dy[8] = { -1, 0, 1, 0, -1, 1, 1, -1 }, dx[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };
struct Pos {
  int y, x, faint;
  bool out;
  bool operator<(const Pos& rhs) const {
    if (y != rhs.y) return y > rhs.y;
    return x > rhs.x;
  }
};
int N, M, P, C, D, r_y, r_x, santa_cnt;
int board[50][50];
vector<Pos> santa;
vector<int> score;
void input();

int get_dist(int y0, int x0, int y1, int x1);

void move_rudolf();
void move_santa(int s);
void push_santa(int y, int x, int d);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  input();

  for (int turn = 0; turn < M; ++turn) {
    // 1. 루돌프의 움직임
    move_rudolf();
    if (santa_cnt == 0) break;

    // 2. 산타의 움직임
    for (int s = 1; s <= P; ++s) {
      if (santa[s].out || santa[s].faint > 0) continue;
      move_santa(s);
    }
    if (santa_cnt == 0) break;

    // 3. 기절 시간 줄이기 && 탈락 안한 산타 1점 추가
    for (int s = 1; s <= P; ++s) {
      if (santa[s].out) continue;
      if (santa[s].faint > 0) {
        --santa[s].faint;
      }
      ++score[s];
    }
  }

  for (int s = 1; s <= P; ++s) {
    cout << score[s] << ' ';
  }

  return 0;
}

void move_santa(int s) {
  int dist, c_y = -1, c_x, c_d;
  int y = santa[s].y, x = santa[s].x;
  int min_dist = get_dist(y, x, r_y, r_x);

  // 이동할 좌표 찾기
  for (int d = 0; d < 4; ++d) {
    int yy = y + dy[d], xx = x + dx[d];
    if (yy < 0 || yy >= N || xx < 0 || xx >= N || board[yy][xx] != 0) continue;
    dist = get_dist(yy, xx, r_y, r_x);
    if (dist < min_dist) {
      min_dist = dist;
      c_y = yy; c_x = xx; c_d = d;
    }
  }

  if (c_y == -1) return;

  // 산타 이동
  board[y][x] = 0;
  board[c_y][c_x] = s;
  santa[s].y = c_y; santa[s].x = c_x;

  // 충돌 처리
  c_d = (c_d + 2) % 4;
  if (c_y == r_y && c_x == r_x) {
    score[s] += D;
    int yy = c_y + dy[c_d] * D, xx = c_x + dx[c_d] * D;
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
      board[c_y][c_x] = 0;
      santa[s].out = true;
      --santa_cnt;
    }
    else {
      if (board[yy][xx] != 0) {
        push_santa(yy, xx, c_d);
      }
      board[c_y][c_x] = 0;
      board[yy][xx] = s;
      santa[s].y = yy; santa[s].x = xx;
      santa[s].faint = 2;
    }
  }
}

void push_santa(int y, int x, int d) {
  int s = board[y][x];
  int yy = y + dy[d], xx = x + dx[d];
  if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
    santa[s].out = true;
    board[y][x] = 0;
    --santa_cnt;
    return;
  }
  if (board[yy][xx] != 0) {
    push_santa(yy, xx, d);
  }
  santa[s].y = yy; santa[s].x = xx;
  board[yy][xx] = board[y][x];
  board[y][x] = 0;
}

void move_rudolf() {
  vector<Pos> s_santa = santa;
  int dist, min_dist = 987654321, s_y, s_x;
  sort(s_santa.begin() + 1, s_santa.end());

  // 가장 가까운 산타의 좌표 찾기
  for (int s = 1; s <= P; ++s) {
    if (s_santa[s].out) continue;
    dist = get_dist(r_y, r_x, s_santa[s].y, s_santa[s].x);
    if (dist < min_dist) {
      min_dist = dist;
      s_y = s_santa[s].y; s_x = s_santa[s].x;
    }
  }

  min_dist = 987654321;
  int c_y, c_x, c_d;
  // (y, x)에 위치한 산타와 가장 가까운 방향으로 돌진
  for (int d = 0; d < 8; ++d) {
    int yy = r_y + dy[d], xx = r_x + dx[d];
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) continue;
    dist = get_dist(s_y, s_x, yy, xx);
    if (dist < min_dist) {
      min_dist = dist;
      c_y = yy; c_x = xx; c_d = d;
    }
  }
  r_y = c_y; r_x = c_x;

  // 충돌 있다면 충돌
  if (board[r_y][r_x] != 0) {
    int s = board[r_y][r_x];
    score[s] += C;
    int yy = r_y + dy[c_d] * C, xx = r_x + dx[c_d] * C;
    if (yy < 0 || yy >= N || xx < 0 || xx >= N) {
      board[r_y][r_x] = 0;
      santa[s].out = true;
      --santa_cnt;
    }
    else {
      if (board[yy][xx] != 0) {
        push_santa(yy, xx, c_d);
      }
      board[r_y][r_x] = 0;
      board[yy][xx] = s;
      santa[s].y = yy; santa[s].x = xx;
      santa[s].faint = 2;
    }
  }
}

int get_dist(int y0, int x0, int y1, int x1) {
  return (y0 - y1) * (y0 - y1) + (x0 - x1) * (x0 - x1);
}

void input() {
  cin >> N >> M >> P >> C >> D;
  cin >> r_y >> r_x;
  santa_cnt = P;
  --r_y; --r_x;
  santa.resize(P + 1);
  score.resize(P + 1, 0);
  for (int i = 0; i < P; ++i) {
    int p, y, x;
    cin >> p >> y >> x;
    santa[p] = { y - 1, x - 1, 0, false };
    board[y - 1][x - 1] = p;
  }
}
```
</details>

### 설명
**문제 종료 조건 확인하기**
   모든 산타가 게임에서 탈락하면 그 즉시 게임은 종료된다.

board[y][x] 를 board[yy][xx] 로 옮길 때,
board[y][x] = 0 을 먼저 하고 옮기는 실수 하지 않기.

***

## 2023 하반기 오후 2번 : 코드트리 오마카세
> https://www.codetree.ai/ko/frequent-problems/problems/codetree-omakase/description

### 코드
<details>
<summary>C++</summary>

```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

struct Sushi { int t, x; };
struct Q_Node {
  int t; string name;
  bool operator<(const Q_Node& rhs) const {
    return t > rhs.t;
  }
};
struct G_Node {
  int n, x;
};
unordered_map<string, vector<Sushi>> sushi;
unordered_map<string, G_Node> guests;
priority_queue<Q_Node> query;

int L, Q, guest_num, sushi_num;

void make_query(string& name, int t, int x);

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  cin >> L >> Q;
  int q_type, t, x, n;
  string name;

  while (Q--) {
    cin >> q_type;
    if (q_type == 100) {
      ++sushi_num;
      cin >> t >> x >> name;
      if (guests.count(name) == 0) {
        sushi[name].push_back({ t, x });
      }
      else {
        G_Node& guest = guests[name];
        if (x == guest.x) {
          --sushi_num;
          if (--guest.n == 0) {
            --guest_num;
          }
        }
        else if (x < guest.x) {
          query.push({ t + guest.x - x, name });
        }
        else {
          query.push({ t + guest.x + L - x, name });
        }
      }
    }
    else if (q_type == 200) {
      ++guest_num;
      cin >> t >> x >> name >> n;
      guests[name] = { n, x };
      make_query(name, t, x);
    }
    else if (q_type == 300) {
      cin >> t;
      while (!query.empty()) {
        if (query.top().t <= t) {
          string name = query.top().name;
          --guests[name].n;
          if (guests[name].n == 0) {
            --guest_num;
          }
          --sushi_num;
          query.pop();
        }
        else {
          break;
        }
      }
      cout << guest_num << ' ' << sushi_num << '\n';
    }
  }
}

void make_query(string& name, int t, int x) {
  vector<Sushi>& v = sushi[name];
  for (Sushi& s : v) {
    s.x = (s.x + t - s.t) % L;
    if (s.x == x) {
      --guests[name].n;
      --sushi_num;
      if (guests[name].n == 0) {
        --guest_num;
      }
      continue;
    }
    else if (x > s.x) {
      query.push({ t + x - s.x, name });
    }
    else {
      query.push({ t + x + L - s.x, name });
    }
  }
  v.clear();
}
```
</details>

### 설명
사람이 착석한 이후부터는, 스시들이 먹히는 시간을 계산할 수 있게 된다.

따라서 사람이 착석할 때, 존재하는 스시들을 {먹히는 시간, 스시 이름} 의 형태로 우선순위 큐에 저장하고,

사진 촬영을 할 때, 즉 쿼리가 주어질 때, 우선순위 큐에서 해당 시간 이전에 먹히는 모든 스시들을 처리하고 출력을 진행한다.

이러면, 스시들의 개수만큼 쿼리에 들어가고 나가게 되므로 시간 안에 수행할 수 있다.

**시간 복잡도 개선을 위해 해시맵과 해시셋을 사용한다**

해시맵과 해시 셋은, 내부를 정렬하지는 않지만 검색을 O(1) 에 수행한다.

***

## 2023 상반기 오전 1번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2023 상반기 오전 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2023 상반기 오후 1번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2023 상반기 오후 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2022 하반기 오전 1번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2022 하반기 오전 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2022 하반기 오후 1번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***

## 2022 하반기 오후 2번
> 

### 코드
<details>
<summary>C++</summary>

```cpp

```
</details>

### 설명


***